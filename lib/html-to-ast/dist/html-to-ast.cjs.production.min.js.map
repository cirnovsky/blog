{"version":3,"file":"html-to-ast.cjs.production.min.js","sources":["../src/element.ts","../src/parse-tag.ts","../src/parse.ts","../src/stringify.ts"],"sourcesContent":["export const htmlVoidElements = [\r\n    'area',\r\n    'base',\r\n    'basefont',\r\n    'bgsound',\r\n    'br',\r\n    'col',\r\n    'command',\r\n    'embed',\r\n    'frame',\r\n    'hr',\r\n    'image',\r\n    'img',\r\n    'input',\r\n    'isindex',\r\n    'keygen',\r\n    'link',\r\n    'menuitem',\r\n    'meta',\r\n    'nextid',\r\n    'param',\r\n    'source',\r\n    'track',\r\n    'wbr'\r\n  ]","import { Comment, IDoc } from './types';\r\nimport { htmlVoidElements } from './element';\r\n\r\nconst attrRE = /\\s([^'\"\\s><=]+)(?:\\s*=\\s*(['\"])([^]*?)\\2)?/g;\r\n// Regular expression for matching and capturing attributes and their values in an HTML tag.\r\n\r\nexport const parseTag = (tag: string): IDoc | Comment => {\r\n  const res: IDoc = {\r\n    type: 'tag',\r\n    name: '',\r\n    voidElement: false,\r\n    attrs: {},\r\n    children: [],\r\n  };\r\n\r\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/);\r\n  if (tagMatch) {\r\n    res.name = tagMatch[1];\r\n    res.voidElement =\r\n      htmlVoidElements.includes(tagMatch[1]) ||\r\n      tag.charAt(tag.length - 2) === '/';\r\n\r\n    if (res.name.startsWith('!--')) {\r\n      const endIndex = tag.indexOf('-->');\r\n      return {\r\n        type: 'comment',\r\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : '',\r\n      };\r\n    }\r\n  }\r\n\r\n  const reg = new RegExp(attrRE);\r\n  let result = null;\r\n  for (;;) {\r\n    result = reg.exec(tag);\r\n\r\n    if (result === null) {\r\n      break;\r\n    }\r\n\r\n    if (!result[0].trim()) {\r\n      continue;\r\n    }\r\n\r\n    const attrName = result[1];\r\n    const attrValue = result[3]; // Capture the attribute value without quotes\r\n\r\n    if (attrName && attrValue !== undefined) {\r\n      res.attrs[attrName] = attrValue;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};","import type { Attr, IOptions } from './types';\r\n\r\nimport { parseTag } from './parse-tag';\r\n\r\nconst tagRE = /<[a-zA-Z0-9\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g;\r\nconst whitespaceRE = /^\\s*$/;\r\n\r\n// re-used obj for quick lookups of components\r\nconst empty = Object.create(null);\r\n\r\ninterface MaybeDoc {\r\n  type?: string;\r\n  text?: string;\r\n  content?: string;\r\n  voidElement?: boolean;\r\n  name?: string;\r\n  style?: string[];\r\n  attrs?: Attr;\r\n  children?: MaybeDoc[];\r\n  comment?: string;\r\n}\r\n\r\nexport const parse = (html: string, options: Partial<IOptions> = {}) => {\r\n  options || (options = {});\r\n  options.components || (options.components = empty);\r\n  const result: MaybeDoc[] = [];\r\n  const arr: MaybeDoc[] = [];\r\n  let current: MaybeDoc;\r\n  let level = -1;\r\n  let inComponent = false;\r\n\r\n  // handle text at top level\r\n  if (html.indexOf('<') !== 0) {\r\n    var end = html.indexOf('<');\r\n    result.push({\r\n      type: 'text',\r\n      content: end === -1 ? html : html.substring(0, end),\r\n    });\r\n  }\r\n  // @ts-ignore\r\n  html.replace(tagRE, function (tag, index) {\r\n    if (inComponent) {\r\n      if (tag !== '</' + current.name + '>') {\r\n        return '';\r\n      } else {\r\n        inComponent = false;\r\n      }\r\n    }\r\n    const isOpen = tag.charAt(1) !== '/';\r\n    const isComment = tag.startsWith('<!--');\r\n    const start = index + tag.length;\r\n    const nextChar = html.charAt(start);\r\n\r\n    let parent: MaybeDoc | MaybeDoc['children'];\r\n\r\n    if (isComment) {\r\n      const comment = parseTag(tag);\r\n\r\n      // if we're at root, push new base node\r\n      if (level < 0) {\r\n        result.push(comment);\r\n        return result\r\n      }\r\n      parent = arr[level];\r\n      if (parent && parent.children && Array.isArray(parent.children)) {\r\n        parent.children.push(comment);\r\n      }\r\n      return result\r\n    }\r\n\r\n    if (isOpen) {\r\n      level++;\r\n\r\n      current = parseTag(tag);\r\n      if (\r\n        current.type === 'tag' &&\r\n        current.name &&\r\n        options.components &&\r\n        options.components[current.name]\r\n      ) {\r\n        current.type = 'component';\r\n        inComponent = true;\r\n      }\r\n\r\n      if (\r\n        !current.voidElement &&\r\n        !inComponent &&\r\n        nextChar &&\r\n        nextChar !== '<' &&\r\n        Array.isArray(current.children)\r\n      ) {\r\n        current.children.push({\r\n          type: 'text',\r\n          content: html.slice(start, html.indexOf('<', start)),\r\n        });\r\n      }\r\n\r\n      // if we're at root, push new base node\r\n      if (level === 0) {\r\n        result.push(current);\r\n      }\r\n\r\n      parent = arr[level - 1];\r\n\r\n      if (parent && parent.children) {\r\n        parent.children.push(current);\r\n      }\r\n\r\n      arr[level] = current;\r\n    }\r\n\r\n    if (!isOpen || current.voidElement) {\r\n      if (\r\n        level > -1 &&\r\n        (current.voidElement || current.name === tag.slice(2, -1))\r\n      ) {\r\n        level--;\r\n        // move current up a level to match the end tag\r\n        current = level === -1 ? (result as MaybeDoc) : arr[level];\r\n      }\r\n      if (!inComponent && nextChar !== '<' && nextChar) {\r\n        // trailing text node\r\n        // if we're at the root, push a base text node. otherwise add as\r\n        // a child to the current node.\r\n        parent = level === -1 ? result : (arr[level].children as MaybeDoc[]);\r\n\r\n        // calculate correct end of the content slice in case there's\r\n        // no tag after the text node.\r\n        const end = html.indexOf('<', start);\r\n        let content = html.slice(start, end === -1 ? undefined : end);\r\n        // if a node is nothing but whitespace, collapse it as the spec states:\r\n        // https://www.w3.org/TR/html4/struct/text.html#h-9.1\r\n        if (whitespaceRE.test(content)) {\r\n          content = ' ';\r\n        }\r\n        // don't add whitespace-only text nodes if they would be trailing text nodes\r\n        // or if they would be leading whitespace-only text nodes:\r\n        //  * end > -1 indicates this is not a trailing text node\r\n        //  * leading node is when level is -1 and parent has length 0\r\n        if ((end > -1 && level + parent.length >= 0) || content !== ' ') {\r\n          if (parent && Array.isArray(parent)) {\r\n            parent.push({\r\n              type: 'text',\r\n              content: content,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  return result;\r\n};\r\n","import { Attr, IDoc } from './types';\r\n\r\nfunction attrString(attrs: Attr) {\r\n  const buff = [];\r\n  for (let key in attrs) {\r\n    buff.push(key + '=\"' + attrs[key] + '\"');\r\n  }\r\n  if (!buff.length) {\r\n    return '';\r\n  }\r\n  return ' ' + buff.join(' ');\r\n}\r\n\r\nfunction _stringify(buff: string, doc: IDoc): string {\r\n  switch (doc.type) {\r\n    case 'text':\r\n      return buff + doc.content;\r\n    case 'tag':\r\n      buff +=\r\n        '<' +\r\n        doc.name +\r\n        (doc.attrs ? attrString(doc.attrs) : '') +\r\n        (doc.voidElement ? '/>' : '>');\r\n      if (doc.voidElement) {\r\n        return buff;\r\n      }\r\n      return buff + doc.children.reduce(_stringify, '') + '</' + doc.name + '>';\r\n    case 'comment':\r\n      buff += '<!--' + doc.comment + '-->';\r\n      return buff;\r\n    default:\r\n      return '';\r\n  }\r\n}\r\n\r\nexport const stringify = (doc: IDoc[]) => {\r\n  return doc.reduce(function (token: string, rootEl: IDoc) {\r\n    return token + _stringify('', rootEl);\r\n  }, '');\r\n};\r\n"],"names":["htmlVoidElements","attrRE","parseTag","tag","res","type","name","voidElement","attrs","children","tagMatch","match","includes","charAt","length","startsWith","endIndex","indexOf","comment","slice","reg","RegExp","result","exec","trim","attrName","attrValue","undefined","tagRE","whitespaceRE","empty","Object","create","_stringify","buff","doc","content","key","push","join","attrString","reduce","html","options","components","current","arr","level","inComponent","end","substring","replace","index","parent","isOpen","isComment","start","nextChar","Array","isArray","test","token","rootEl"],"mappings":"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"}