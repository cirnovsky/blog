---
date: '2020-09-19'
title: 'Ds100p -「数据结构百题」11~20'

---

# 11.P3203 [HNOI2010]弹飞绵羊

某天，$Lostmonkey$ 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。  

游戏一开始，$Lostmonkey$ 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$ 步，达到第 $i+k_i$ 个装置，若不存在第 $i+k_i$ 个装置，则绵羊被弹飞。  

绵羊想知道当它从第 $i$ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，$Lostmonkey$ 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。

-------

每个弹力装置只会对应一个位置可以弹到，也就是说我们可以把它看作一条边，而且不会有环这种**玩意。

对于修改弹力系数，我们可以用断边连边来维护

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

const int SIZE = 2e5 + 5;
class LinkCutTree {
public:
    struct SPLAY {
        int val;
        int fa;
        int ch[2];
    } T[SIZE];
    inline bool isroot(int x) { return !(T[T[x].fa].ch[0] ^ x && T[T[x].fa].ch[1] ^ x); }
    inline void push(int x) { T[x].val = T[T[x].ch[0]].val + T[T[x].ch[1]].val + 1; }
    inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, k = T[y].ch[1] == x, w = T[x].ch[!k]; (isroot(y)) && (T[z].ch[T[z].ch[1] == y] = x); T[x].ch[!k] = y, T[y].ch[k] = w; (w) && (T[w].fa = y); T[y].fa = x; T[x].fa = z; push(y); }
    inline void splay(int x) { for(; isroot(x); rotate(x)) { int y = T[x].fa, z = T[y].fa; (isroot(y)) && (rotate(T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ?  x : y), 1); } push(x); }
    inline void access(int x) { for(int y = 0; x; x = T[y = x].fa) splay(x), T[x].ch[1] = y, push(x); }
} lct_mast;
int n, m;

signed main() {
    scanf("%d", &n);
    for(int i = 1, s; i <= n; ++i) {
        lct_mast.T[i].val = 1;
        scanf("%d", &s);
        (i + s <= n) && (lct_mast.T[i].fa = i + s);
    }
    for(scanf("%d", &m); m; --m) {
        int opt, x, y;
        scanf("%d", &opt), scanf("%d", &x);
        if (opt ^ 2) {
            lct_mast.access(x + 1);
            lct_mast.splay(x + 1);
            printf("%d\n", lct_mast.T[x + 1].val);
        } else {
            scanf("%d", &y);
            lct_mast.access(x + 1);
            lct_mast.splay(x + 1);
            lct_mast.T[x + 1].ch[0] = lct_mast.T[lct_mast.T[x + 1].ch[0]].fa = 0;
            (x + y + 1 <= n) && (lct_mast.T[x + 1].fa = x + y + 1);
            lct_mast.push(x + 1);
        }
    }
    return 0;
}
```

# 12.SP4487 GSS6 - Can you answer these queries VI

The first line of the input contains an integer N.  
The following line contains N integers, representing the starting  
sequence A1..AN, _(|Ai| <= 10000)_.  
  
The third line contains an integer Q. The next Q lines contains the operations in following form:  
  
**I x y**: insert element y at position x _(between x - 1 and x)_.  
**D x** : delete the element at position x.  
**R x y**: replace element at position x with y.  
**Q x y**: print max{Ai + Ai+1 + .. + Aj | x <= i <= j <= y}.  
  
All given positions are valid, and given values are between -10000 and +10000.  
  
The sequence will never be empty.

------

这道题显然是一道平衡树的裸题，唯一的难度就是求最大子段和。

可以类比线段树维护最大子段和，维护$lmax$以x为根的前缀最大和、$rmax$以x为根的后缀最大和、$maxsum$最大子段和以及$sum$总和

对于$Update$我们可以对是否有左右孩子做讨论。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <queue>
#include <utility>

using namespace std;

const int SIZE = 2e5 + 5;
int n, m, tot, root, a[SIZE];
struct SPLAY {
	int fa;
	int ch[2];
	int siz;
	int val;
	int sum;
	int lmax;
	int rmax;
	int maxsum;
} T[SIZE];
vector < int > st;

inline int newnode(int v = 0) {
	int x;
	if (st.empty()) x = ++tot;
	else x = st.back(), st.pop_back();
	T[x].fa = T[x].ch[0] = T[x].ch[1] = 0;
	T[x].siz = 1;
	T[x].val = T[x].sum = T[x].maxsum = v;
	T[x].lmax = T[x].rmax = max(v, 0);
	return x;
}

inline void delnode(int x) {
	T[x].fa = T[x].ch[0] = T[x].ch[1] = 0;
	T[x].sum = T[x].lmax = T[x].rmax = T[x].maxsum = 0;
	T[x].siz = 1;
	st.push_back(x);
}

inline bool which(int x) {
	if (T[T[x].fa].ch[0] == x) return 0;
	if (T[T[x].fa].ch[1] == x) return 1;
	return -1;
}

inline void update(int x) {
	T[x].sum = T[x].val; T[x].siz = 1;
	if (T[x].ch[0]) T[x].sum += T[T[x].ch[0]].sum, T[x].siz += T[T[x].ch[0]].siz;
	if (T[x].ch[1]) T[x].sum += T[T[x].ch[1]].sum, T[x].siz += T[T[x].ch[1]].siz;
	if (T[x].ch[0] && T[x].ch[1]) {
		T[x].lmax = max(T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val + T[T[x].ch[1]].lmax);
		T[x].rmax = max(T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val + T[T[x].ch[0]].rmax);
		T[x].maxsum = max({T[T[x].ch[0]].maxsum, T[T[x].ch[1]].maxsum, T[T[x].ch[0]].rmax + T[x].val + T[T[x].ch[1]].lmax});
	} else if (T[x].ch[0]) {
		T[x].lmax = max({T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val, 0});
		T[x].rmax = max(T[x].val + T[T[x].ch[0]].rmax, 0);
		T[x].maxsum = max(T[T[x].ch[0]].maxsum, T[T[x].ch[0]].rmax + T[x].val);
	} else if (T[x].ch[1]) {
		T[x].lmax = max(T[x].val + T[T[x].ch[1]].lmax, 0);
		T[x].rmax = max({T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val, 0});
		T[x].maxsum = max(T[T[x].ch[1]].maxsum, T[T[x].ch[1]].lmax + T[x].val);
	} else {
		T[x].maxsum = T[x].val;
		T[x].lmax = T[x].rmax = max(T[x].val, 0);
	}
}

inline void rotate(int x) {
	if (!x) return;
	int w = which(x), y = T[x].fa;
	if (~which(y)) T[T[y].fa].ch[which(y)] = x;
	T[x].fa = T[y].fa;
	T[y].ch[w] = T[x].ch[w ^ 1];
	if (T[x].ch[w ^ 1]) T[T[x].ch[w ^ 1]].fa = y;
	T[x].ch[w ^ 1] = y;
	T[y].fa = x;
	update(y), update(x);
}
inline void splay(int x, int &goal) {
	if (x == goal) return;
	int p = T[goal].fa;
	for (int y; T[x].fa ^ p; rotate(x)) y = T[x].fa, (T[y].fa ^ p) && (rotate(which(y) ^ which(x) ? x : y), 1);
	goal = x;
}

inline int kth_element(int x, int k) {
	while (233) {
		if (T[x].ch[0] && k <= T[T[x].ch[0]].siz) x = T[x].ch[0];
		else {
			if (T[x].ch[0]) k -= T[T[x].ch[0]].siz;
			if (!--k) return x;
			x = T[x].ch[1];
		}
	}
}

inline void insert(int &rt, int p, int val) {
	int x = kth_element(rt, p);
	splay(x, rt);
	int y = kth_element(rt, p + 1);
	splay(y, T[rt].ch[1]);
	T[y].ch[0] = newnode(val);
	T[T[y].ch[0]].fa = y;
	update(T[y].ch[0]);
	update(y), update(x);
}

inline void erase(int &rt, int p) {
	int y = kth_element(rt, p);
	splay(y, rt);
	int x = kth_element(rt, p + 1);
	splay(x, T[rt].ch[1]);
	int z = T[x].ch[1];
	T[z].fa = y;
	T[y].ch[1] = z;
	delnode(x);
	update(y);
}

inline void modify(int &rt, int p, int val) {
	int x = kth_element(rt, p + 1);
	splay(x, rt);
	T[x].val = val;
	update(x);
}

inline int find(int &rt, int l, int r) {
	int x = kth_element(rt, l);
	splay(x, rt);
	int y = kth_element(rt, r + 2);
	splay(y, T[rt].ch[1]);
	return T[T[y].ch[0]].maxsum;
}

inline void make(int p, int l, int r) {
	int mid = (l + r) >> 1;
	T[p].val = a[mid];
	if (mid - 1 >= l) T[p].ch[0] = newnode(), T[T[p].ch[0]].fa = p, make(T[p].ch[0], l, mid - 1);
	if (mid + 1 <= r) T[p].ch[1] = newnode(), T[T[p].ch[1]].fa = p, make(T[p].ch[1], mid + 1, r);
	update(p);
}

signed main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
	int root = newnode();
	make(root, 0, n + 1);
	scanf("%d", &m);
	for (int i = 1; i <= m; ++i) {
		char opt[2];
		int x, y;
		scanf("%s %d", opt, &x);
		if (*opt ^ 'D') scanf("%d", &y);
		if (*opt == 'I') insert(root, x, y);
		if (*opt == 'D') erase(root, x);
		if (*opt == 'R') modify(root, x, y);
		if (*opt == 'Q') printf("%d\n", find(root, x, y));
	}
	return 0;
}
```

# 13.Count on a tree

给定一棵 $n$ 个节点的树，每个点有一个权值。有 $m$ 个询问，每次给你 $u$,$v$,$k$ 你需要回答 $u \text{ xor last}$ 和 $v$ 这两个节点间第 $k$ 小的点权。

------------------------------------

## LYC

树上的路径问题，我们一般都要用树链剖分。

静态第$k$小的问题，我们一般用主席树。

经过~~严谨~~分析，我们得出，这道题是树剖加主席树。

把树剖成重链之后像主席树模板那样按$dfs$序插入每个数(让同一条重链在主席树的$root$数组中成为一个连续的区间，方便统计)，然后我们要查询$u$,$v$两个节点间的第$k$小。

和模板不一样的地方来了：这里的区间第$k$小的区间不连续。

我们回想模板的思想过程：

通过差分得出区间内每个数值出现的个数。

既然这次区间是不连续的，我们就每次都把这些不连续的子区间统计一遍，再加起来就好了，就相当于是把这些子区间合起来。

具体来说，就是树剖$LCA$时记录每个区间的左右端点。使用主席树查询时再把原来的对于一个区间的统计改为对很多区间的统计就好了。

剩下的就和模板一样了。

代码：
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int n,m,p,a[100010],last,u,v,w,fa[100010],dep[100010],son[100010],siz[100010],dfn[100010],ton[100010],hb[100010],tot,be[100010],en[100010],cnt,root[100010],cntot;
struct node
{
	int l,r,sum;
}nodes[4000010];
vector<int> e[100010],pri;
int getID(int val)
{
	return lower_bound(pri.begin(),pri.end(),val)-pri.begin()+1;
}//离散化
void dfs1(int x,int las)
{
	dep[x]=dep[las]+1;
	fa[x]=las;
	siz[x]=1;
	int b=-1e9,s=0;
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i];
		if(y^las)
		{
			dfs1(y,x);
			siz[x]+=siz[y];
			if(siz[y]>b)
			{
				b=siz[y];
				s=y;
			}
		}
	}
	son[x]=s;
}
void dfs2(int x,int las,int heavy)
{
	if(heavy)	hb[x]=hb[las];
	else	hb[x]=x;
	dfn[x]=++tot;
	ton[tot]=a[x];
	if(son[x])	dfs2(son[x],x,1);
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i];
		if(y^las&&y^son[x])	dfs2(y,x,0);
	}
}
void LCA(int x,int y)
{
	int fx=hb[x],fy=hb[y];
	while(fx^fy)
	{
		if(dep[fx]<dep[fy])
		{
			swap(fx,fy);
			swap(x,y);
		}
		be[++cnt]=root[dfn[fx]-1];
		en[cnt]=root[dfn[x]];//记录每一个区间的左端点-1和右端点，相当于原来find(int l,int r,int p1,int p2,int k)中的p1,p2。
		x=fa[fx];
		fx=hb[x];
	}
	be[++cnt]=root[min(dfn[x],dfn[y])-1];
	en[cnt]=root[max(dfn[x],dfn[y])];
	//所有的子区间中的数包含且仅包含了u到v的最短路径上的所有点。因为树剖LCA会用一个一个区间覆盖所有点，而我们记录了每一个区间。
}//树剖
void ins(int l,int r,int pre,int &now,int pos)
{
	nodes[++cntot]=nodes[pre];
	now=cntot;
	++nodes[now].sum;
	if(l==r)	return;
	int mid=(l+r)>>1;
	if(pos<=mid)	ins(l,mid,nodes[pre].l,nodes[now].l,pos);
	else	ins(mid+1,r,nodes[pre].r,nodes[now].r,pos);
}
int find(int l,int r,int k)
{
	if(l==r)	return pri[l-1];//一直到确定第k小的位置；返回原值。
	int X=0;
	for(int i=1;i<=cnt;++i)	X+=(nodes[nodes[en[i]].l].sum-nodes[nodes[be[i]].l].sum);
	//临时统计u到v的最短路径上的所有点权中在[l,mid]中的数的个数。
	int mid=(l+r)>>1;
	if(k<=X)//k<=X,说明第k小在左边
	{
		for(int i=1;i<=cnt;++i)//把每个端点都往左下跳。使它代表的值为这个区间的元素值在[l,mid]的个数。
		{
			en[i]=nodes[en[i]].l;
			be[i]=nodes[be[i]].l;
		}
		//然后我们就可以去缩小范围，去查询[l,mid]这个区间了。
		return find(l,mid,k);
	}
	else//否则，第k小是右边的第k-X小
	{
		for(int i=1;i<=cnt;++i)//把每个端点都往右下跳。道理同上。
		{
			en[i]=nodes[en[i]].r;
			be[i]=nodes[be[i]].r;
		}
		return find(mid+1,r,k-X);//继续查找
	}
}//主席树
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);
		pri.push_back(a[i]);
	}
	for(int i=1;i<n;++i)
	{
		scanf("%d %d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	sort(pri.begin(),pri.end());
	pri.erase(unique(pri.begin(),pri.end()),pri.end());
	dfs1(1,1); 
	dfs2(1,1,0);
	p=pri.size();
	for(int i=1;i<=n;++i)	ins(1,p,root[i-1],root[i],getID(ton[i]));//按dfs序插入
	for(int i=1;i<=m;++i)
	{
		scanf("%d %d %d",&u,&v,&w);
		u^=last;
		cnt=0;
		LCA(u,v);
		last=find(1,p,w);
		printf("%d\n",last);
	}
	return 0;
}
```

## WGY

对于每一个节点$x$，先令$rt_x=rt_{x-1}$，然后在$rt_x$中插入$a_i$，这样其实每个节点维护的都是节点到根的信息

对于查询操作中的每一个$(x,y)$，我们可以用$rt_x+rt_y-rt_{lca_{x,y}}-rt_{fa_{lca_{x,y}}}$来得到答案

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define mid ((l + r) >> 1)

const int SIZE = 1e5 + 5;
struct TreeNode {
    int l, r;
    int size;
} fhq[SIZE << 5];
int n, m, tot, fa[SIZE], rt[SIZE];
int a[SIZE], rnk[SIZE], dp[SIZE], inq[30][SIZE], lastans, Q[SIZE];
std::vector < std::vector < int > > G(SIZE);

inline bool cmp(int x, int y) { return a[x] < a[y]; }

inline void newnode(int t, int p) {
    fhq[++tot] = fhq[rt[t]];
    rt[t] = tot;
    int u = rt[t], l = 1, r = n;
    while (l ^ r) {
        fhq[u].size++;
        if (p <= mid) fhq[++tot] = fhq[fhq[u].l], fhq[u].l = tot, u = fhq[u].l, r = mid;
        else fhq[++tot] = fhq[fhq[u].r], fhq[u].r = tot, u = fhq[u].r, l = mid + 1;
    }
    fhq[u].size++;
}

inline int find(int a, int b, int c, int d, int l, int r, int u) {
    if (l ^ r)
        if (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size >= u) return find(fhq[a].l, fhq[b].l, fhq[c].l, fhq[d].l, l, mid, u);
        else return find(fhq[a].r, fhq[b].r, fhq[c].r, fhq[d].r, mid + 1, r, u - (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size));
    else return l;
}

inline void dfs(int x, int fa) {
    dp[x] = dp[fa] + 1;
    rt[x] = rt[fa];
    ::fa[x] = fa;
    newnode(x, a[x]);
    for (int i = 0; i < (int)G[x].size(); ++i) if (G[x][i] ^ fa) dfs(G[x][i], x);
}
inline int lca_mast(int x, int y) {
    if (dp[x] < dp[y]) std::swap(x, y);
    for (int i = 0; dp[x] - dp[y]; ++i) if ((1 << i) & (dp[x] - dp[y])) x = inq[i][x];
    if (x ^ y) { for (int i = 25; i >= 0; --i) if (inq[i][x] ^ inq[i][y]) x = inq[i][x], y = inq[i][y]; return fa[x]; }
    else return x;
}

signed main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), Q[i] = i;
    std::sort(Q + 1, Q + 1 + n, cmp);
    for (int i = 1; i <= n; ++i) rnk[i] = a[Q[i]], a[Q[i]] = i;
    for (int i = 1, x, y; i < n; ++i) scanf("%d %d", &x, &y), G[x].push_back(y), G[y].push_back(x);
    dfs(1, 0);
    for (int i = 1; i <= n; ++i) inq[0][i] = fa[i];
    for (int i = 1; i < 26; ++i) for (int j = 1; j <= n; ++j) inq[i][j] = inq[i - 1][inq[i - 1][j]];
    for (int i = 1; i <= m; ++i) {
        int x, y, z;
        scanf("%d %d %d", &x, &y, &z);
        x ^= lastans;
        int lca = lca_mast(x, y);
        printf("%d\n", lastans = rnk[find(rt[x], rt[y], rt[lca], rt[fa[lca]], 1, n, z)]);
    }
    return 0;
}
```

# 14.P2486 [SDOI2011]染色

![fig.webp](data:image/webp;base64,UklGRjw/AABXRUJQVlA4IDA/AABQsACdASqCAtQAPpFCnUslo6KhpHLrGLASCWdu/HyZcemZe2VjqvKa5n8K48tYVkzyaIJ/Qt/o/UA53PmJ84/0i/2b0o/Sp/3nsR/t77GfnSeqR/jOkA///qAf/XrR+h/9V/j/8S/sn878I/69/D/5h/dP616X99jv9+Qf17+8/1X/5e33+v+GyJZ8c+mX4P+rfyj/gf3T5pfoX8s/Jn+sejvyO/uPUF/I/4d/nP5v/If+h/ePT1/N/yb/tf//8rrWP75/v/7T+xHwBetfw7/PfxP/4/7v+p/EJ6J/EvyO/r3////f0Z+d/z7/Pf1f8UvsA/lH8R/0/8U/9//l/lX///8P2J/Tf9r/U/3b9b/zX2Af4d/Hf85/kf53/rv75////v+L36T/gP6X+5/+A////3+NH5l/SP+r/evxg+wb+Pfxn/bf4L+1/+z/Kf///5fcZ6v/2h9gz9Yf9P/tv3r/f8ssJp0MQf7cqikar6jiwmnQxB/tyqKRquYGZwdujjHnaP6Snj3X99SRuUoqwo6nT4wvNlpi/tvmnzEbIGHJLWC5u/gonfhBTx7SK0eGpBClEbHjrFgHx1JFVuyKDYIzKrBCFPSnBfG0h/h51eLCadDEH+3DP87UGA60F2axkPi6bsvPWgvyFfK59rTUHAjwmFCjNtRS2sX0z/8RMoiTGhdpGCHl8yL27+Orl+PRQFBJhpFXj/V7feU2BMiJxZkCagol4FSy3EM0JiKmuCLpj9FgemjvEBVpdjwDmtUu0yNV9RxYclOGbDw906GIP+GaopGq+o4sJp0MQNf0XyA8DcAN1aGHmzRU3LFP05iX8XWp4siCSI1pp6BHnlYwCwx+hoWAacGOZqjfRRiK4rCTKM/jwXHWf6hgRtB1suGedkgwfdHQxB/tyqKRqW8gjlWCGWmahK+p8MBEYbFjryV7PCD00FEb3ohFLChOy/mpkR8XxiOW/W0Sn4btnOFcmDMqDK9ATOZqVK89F4bV9bp0MQf7cqikar6jiw5JASO6dDJ44r29uVRSNV9RxXkKgA57otZGVeUW/hF7o7A5/MW39DrAzteUNjpP0YwQ/d8eV4lmeqldFxE52mt7SgtGsnof9f+P+BIIuJ41C3kZHd3Kta0b9E1stLwCDREAoTElwONVtSdhxdf+X+uGjo6/o7dKwKEuI9iaAaf6ZrQFbWUuEH2uCSNtiCvZAI6k/CgXjhepJRXL3OeqFzs3S/gIQgaRhuyTaRO5UeL58x7LhAu/eD7hV55ORz6xlJnscLW15Vf5RXsgqw2viefY9HFjHrEpnzG8Z6C8IpKTL9CEetPLP0eQw5naQwoMRtLGTBwnHPvL5VvRx+cnx4oh9CGTcOenJTAYzMii7tORb/Hjh51S02mahpQRuOWieEwG/S2Rf1VL7GvffnBy7livRbMxDmZTrHpqOVbq5qYPUPlmnR9LYmwZTYYLcYhq0VyUEvCCRGFztISZ2GiQ0HufKfDICkbFLP2b1fGDyuZm3XLufZoYvUROCmeKWDp3bQrcBUPDyQNgg+hGJ3ZTjFzraSNWuNtdUKiobkSu/xoc4ehAGrFI1X1G0c4wxEz8szjQI5X7bGnVrfFhc8HWxFchGhs/iIPnFOhzXmwRPJXJqDUCb4epxyJYLViwaVR4ScwtCsZpXTNUgLoclfimxEaZ+QWuf+3KopGq+o4lP5Lf9gYtQ8A8m0xFaDEGvdPV55q50t8DO2ogixfG4aP++35LMXtUlDrhITTuHQ+Q6TMvoioVadUGiQ6O427Q33pJwypwgh4GV/bMcn1CEZ7jHU18qCOvjhT/qP+QsIYwfc5Eba5DLmqJat/4o75YTToYg/25VC95kUxqbvZosfyC25iiONCY3Mgg7TI1X1HFhNOhPAAA/v+AIAAFr0kTIRlqpQnwCYrLBqvPgGiy/+7NMP/Ne1V+0Y2zB/99dZ1/Y+xH7YFrV7fdzhSA7/a2QazQoPlmbE7+JXYBUY53JQVufZPcr2UG/Sw6B+Qea0jNgSVt/wAiO7Pt7whGdVVYEim94s6LfdGL39+4kzdDil/t/m+FSh9Y9qeqYdAdsSUe1cgmXNLlFvAOmwuc0yTO+Dql/ozTcO17Xdo8Q3FFksy6Tz0YwgxHsawG8lZehRVzwibk/a8W6Y/xJcFwzoJu252ws5skP1XT1jMxWx3R8IqisSrXf+pY+xNVgvVp8GqQKEM+I71al9NKcEwPL7r1uHjw6bJiTdzfGonmXAivZUWJWnmfZ9d7gaV6tCU3rt0p57BUsr7IpDb0U7x4xNqHBLXACzZF9oJd7YhA5g8oh1IP5FjB3om1TKHwe/bytb5A/KJ00aeQOg3CV5LjLlbhao5VaocvsGMcd5t2ZM77a4QxnMzb9wAsU7BpW65uvlQtWpHj8ksvlq2mlKFExPNkww/Pyn13x4rs/NO022MS7PXZIOsnRGQQ3Jpj0HNJuG7rCauu/Pu8R/D1ZvhGOucPW0kzidSLr9qBnZCAp4IY5UTO6KvoupUgL7MwhQ+DkShuwarRu7nWtCXlpqmGUP71PIFjtdxnDew/Gf4zNqlG7p/YhWWowuenhWJ4sbvix9qcaFhOnnY2REbgTazQIvqzPrfez8xNlmtUjSsqRueDsEK0JIePcZvCI4NkHFDbIwx2yQduk5qC+CHdl4EZ0RkSz+dNGCOL5DrclZoC0DSyzxnaOKBlaR8dJsBNnC5I7w6oJV8blUGX2u3dp2s4qlmyMaqFlwPy9XVZDXeIiLZ1RDitLsqRfotAJYcv/cvma1LiDbMwT0+2EXYHOPAIL4/AAn0mZwuCGCQi4Q/Kr0hK16LOOcIXH6rcrvNwHCU7t3d0kH2VpcVzs63zreaAWOAf7h8nIcUYKxAtysVFyiu/Up2cBpJuxKI9kChDPhfDxdzdQfUELfk7mf6HQ9q9wxH1RfY4m6DHe57wHMIYGZ/hKuRVTxcIcVjDT+Ol9vk2tBWDrzOCNouSHLKrwhPC5Cged4xwypOpThTZdO3WPtwqJDDpyl1IBd4ssjOVcO4Ra1+1TLVRDitLsqSrpSgGiQXJEWRRnuxj2RlzMTpZkBfKjbKIIjakOj3oaCd/Ikq21xFcxTxSZGSGbb8vuvZ6/ZvcROCutxwYp7FarHAupkNxvShT3mcu3DBmnDGuKz6eO51icHo/52LvriDEhZqhDajJZzjeu1mT43D6fjAY9mvvZSjCkvTyocxCUx7rYwKNXs659K7LNglIseklz9IUvWu5MisfA3oXMjAqbDdnn1yN/XfaSXZNOFxXRHNHpP5gohP5E6TaW67JB1k6IyB9+gbCl0FDtEtj8jMQwAV/6HNNhG2/wD0zH0VpCeYLMbIC6wd7gNHpsFKCezuclGvLZ5G0l8J1chcuWa1SNju93hm5QZdaLoy8MxZGi5ieBxb78I/6a2N8ZAJNVCnbCMf5EItPemB4vllzp8rNrp7TtS83ZnOm+NgJVhKorZOgJqbcVQYfxjYMEog4NaOB0KNOd7zKlhuYqvht68KQwFoTv+y14g1OYv2gBJWToLJAL1aEmFf/vhKpF0ZBs5ViS1+O5Gfip+JNEcTZMWxz6VG2i5N1sck31rnvS2aJ0GhIsfoFFYHCL1cTGZvggN+r1TxoO9+ogoUcuFbkcg65uHR5zjJ10G89yLJ/GYi9dnKdPR4axJAlJ9h+5nhRZXqYWJA+R89HiufnC/WxToajMNyYwKfoQevkfmG3Ba09Bn8zjc6KBQatvqyIhEzeqHDg1cKDhgjlFF/NLxSZq3u4aHpwiYQEDrLz2pviMDBtY5xdhwvHjauDTIVH4dU+UGvQv4fnk1yIbnnqVe/rCBBZEVb+gYdWEpltNzedH7IWFtUzJmxXc5z9IfSHVlRvG/P+Vi3bYUz2pjKed3RZta7xW3wOTk0YCrBd6ZZQlV3iaeGAWcgbmPdEmkgG1k1kW6EnBdmHRZBpXBTENt8XaR9rIGAwHFiWPYeJMLOgQEcZ3Aviirza0bRy0Jtu0j0CQqHzlWEGn5SngEPd6RMqg2hZyklEINjrpJvvk4BRBhSz+VFmfCOx0HPiwd4WFZ5mWbL/1xwyYIQ0tjXm1Jh11XCaytwRwhObDOiX0r/jvO2MLgcY62VO2AYsiwxdt9uwoyAEneJvhPLR+0kZK4BVaj9BXWZeOVEzCckpPx0BTTDm/QJhcOLcI2sz/MHBOwZfSRJMpQkpkp1iGrAvEqSHnBqZQbuVUAbjvCXU3HMKyy1fBADSQQPavNGvz1P9o+xeey/uDPxDIf5qZ7hZvxZgIaTgtAPLi46UjfE8KQrapmTIMSH5lOT7FN3GNKMp4zrMS5Jv+WxA6pL+wgdKfV/Rk5luFpWP/8G9cgim1zzyAiezMIJ0Fnh47IXYRbHit1KNb+jSbbXk0wheOp+3EGZb4Dt63OccVcHFQSV8jyhJSO0Vnf+OoVlDHOuxTyMuKfiCJh1olMjss6wfJ4KKaYg/q5MxeCrnc5KMNP6kJp6od+iT6quqL4sslMwgrCMCFYxuonTtQlVhOrDhVfcOzlqepBqz/NXHbuTlaM0w/f33PqPdSO5iqu9vTa1gMd2my4QpT55XQ1VJW3vdZNc6mxObzcyouRqwk9o3GIdfjEG1Hba+4IaoUPWjYGceBlxRBKDCoHFhH14MTMHMBcoNk/DreYqHrlHQ/PuhRhklMxwH+5piMqShyh1BCcQYFI4kSWSo7o+sisfeaQFHstvfP8tlRgK4ua0UkOBF0afKQpMNkHlxUqI0I/QVz9HsRaWIKvRIQ0Aw2IkmUoSUwbXFimkWCtmaL8SyVP75ODAeyU8dil0xrMjOyNGg3FCOzEVee+W2sOl3SxYjJO/0alSoylVA0yLQr3BWJPcJYRj3wKMDjBEOfnLfWmH84VsnQ16jyQnEEAoD8Up88roT7Uz2rKObzczcecvbQsItIzqm9ML8ZzZYZ/tWAkBshR2qo9AobtcjzsbPNh2IvRnEk+fBBIZFJNOJMu/UGGudOVd+YFMR0tLfq2T4STCqNRLoO7Cep5D8JWRwzTpjs0Z0i9puErwKU3YC8TEYaUPCnWqA2wjqhK/BDAzCb90B+KU+eV0Ijs9N75ina5wcAKcEbp2MlUA5Djq9vlhG+7uwC2Ve0mNbFqTNpSW+XPcj/KiRjlibetXqjSgu6h3rkpiFPFFXiDIGzu/J/8/wzVjXKzoT5WdfYiSZShJUVqkx3mGyd4JIpsXubDib95IbHarkSxqZ9d251rw3nMNrwa26+30sN/l0LSJitg7qReIbU1SGVj+XS9gBo9TXMgivz5xzi1FEI+YEm+j814UQnEHC7a+fO7dlmqHLMC+dGrpP0Idz+ecafvvwWxcCwAWrQapG1+dxSQY9VpIEAj0mxqzWNYEzZh2eTKYedZbU3A0TOEyTMENwI7GTQoXUTLxjN+zXefg+LyFAvADolX2OXEra39soJr4hmlsH822olcMYzX5qUfV6c7t2yFQY7R16ZMFEi8eAhi0knmjLlaOsbTUY3TaIA9esX+DuubGOuRn7qEnhd9d3yJhtsGiqjuzdEptMEJTVTaKC8qyytUHivK1vk0O0PfmLqBA+/yutaVUpgLBiWFLcILAet1I2vyEykdeAoum/HlNoqFq6SeQzN8onhLWYAMzMp2mFeCFeQzN8o3exa8/dH9dSoMO3B22iooXYU1cImuJn90DHOKjs/Qt3qsteviAAAAvWyx3botZ6a6coc4GeRFHnYbae/WsDwBgw+52638s7G8Tfo9Uaby7ZvZrLyKX6e/tavrbFmXsVC95uuQCP+dkHT2a8x7iuT0r3rNVLZ0yWfKnptaKz1+bWxeIFpFG/0ZlUerkfK4gwpWaevWSaI7XE9ct8R9BqGfCCyZpwfZL9r8UBiOZlfTwzhEMpWpElZ0AElVrspMak7KFJo3BC9YiT5pu27yZFK3Kc3Ubo2Cya8tvWrngujHS+XjuMKmyO6Qp1XtdUl/YQPUknN7PxGSTV/e6H5LnslW73yxD/KHjvftFSlg5ZpSJGYhfI+WhLlcZ6Tv40zfdud+xwtYOmDJG0OGPFJ4R6N8LGFbN2E1FFJ4GR9BqGfCCxLDdqxLBruruFM77BCU9ijPYMBTobnatalyWJuninQX3Zmp1h8VxL7fI/0WOfUZNXQadVatvyRx4iTYR459DY1cizq+Y11EGUi1+2VRiY3VuU5uo3RoTP2ETMENnvBD19YRbwUmU15RpL2GkKTWUsz3JQthiaTmpyoM8fMXUmATAn4edRYwgRQObHi2UV0cj6NnfOx5sYrZ8AqSwCpUli59uowu/GmAOnYR4bW3WaVR03SSQ0ybtu8mRD5NcPVvFjJe+wevyP1nwcxy5J3Y7JHTHjPwru+p7L6UwFRaLJrKO7F5Jfl2XWvSWZyXQjLB4aWesJB3jP5wZdBeWf5qQX3m+R7VZZya7Vq3/ZcrQEb8blU8ZEQVc2hFnDnECfW4yg7jvJb3nQt0gIOaPbpRQZpDF++aNmV0YOPmOQ0vybq7vedEkGfaCBf7NvCHRgpQ7O96izIfsAVeZBsck31CavsDikWZpw4Qw2AS/W1mnhwHlXFolW2Ny4EFmFkAtOm7qO38AVlh1omAq0Lnw88e+4oCluGdqlzkRIjLJ1o6Ko+gGOOIT5SKH9qA2Nn6sj3ymuFAighefS59wGjSrCdSFS76afqEfJP8Hz5aiBKPIWGvgOioFsJvlZzzGe65G0hLpl5kKlb1Ak41xExsLcMxX/JXR3EYYpfYkitRwrNYkuu3OPqYuAsvGAcUO2JXMKvGG1eMPvGX5/f5cWsMJHQX6grPPV1HClRNVCryPB48tJfHLys5FKuPPgDC4w2EDM5Hgpdcu71y8O3oGvTQE1KxBj/LMJQRRRXRyPo2iAKPj6aw38F5u/1U8c4aIp5igowwdWkoMU/EETD2Ia1Ro0ajJOsFTKPzjmSOmHTnYlNej9g0rSVNGGS971uprkfLsZImmX+HWssGNfFKP0hPjX+Fd31PZfSmC6SNlZmS4V59tOyuIi1UiBUaxQzTg+yX7ayLxL859A7zcB1ACCKFzhcbJpHorPFKYGlLW8AHQtdfqXLCsvOxNkx1FTGpzMO0AOWfgq2O9XpCEgEw95vke1a5ODw6J+J6NHGfamVMOXZdTeoQNYVcE7XDtNKmYrqfm/b3WvKN9ba0LJgYSMORVY8kq/ZI6idkG/WoNbBhl0mi5MaujeY/OhGsFSiL0xrUf3eIqwUDj34GibGcaiI+JidpK7gnxF2o3ZzF07R7MZGDqXJ2GhQjE2XrVHVyTIwgQLZyHlQ4BSh9Y9qeqWXUWZD9gffePas8mRt0f4XI/6qruxrskT3vS7IAvNOXa+jqbxcTlugZTIeGybCosK8L5T1P9+Zf7rqikpb2TRTB240R/q48qroBFSKiica1rI1kRXkX+P0c6L5ErWtya+pJvQ8xnslG19CD3pn/hEn+RWc53UZ77zfI9qxTrSgMmaT5USAoB+V6PCwETD77kxKpt71/hiQSbJaEHqVOHJSNziUpQbNEL8QdqmbQSTrrOHPDeau1BDak8xfANMa7uMZB6cz5W+QeTcyfueplFqZ677KNoVj2/GtvwBw3i8YORseJzH8qkRUAVxXuez/HHuBbldgtqJS66vYYNQPexfTr/560oj7XQxANFqjSew+MfbagqwHnDXA/PkM9HFW3fbUmpRWKo/m6bjP6hbW/q0hHXuktXOnLvISoYJQoo0t/LSb2jd7U6aA0qOmp99Dr0jgR8V0cj6Nrb5QZiaX5VHUqf9AY5ZMHC/7aSuV2Ry0HC6sAVlMhhc4pbQU3KyWLJURwXb0KXl/2ZQQJNkHdLXTftadYumfnKwdhdy0p8vh2USbWUbdh5Ot2oRVWG4ffHcWXBaU2M8jy2mPvjjCAT8vDoUH8j78zqEv85uZaQ90KMYBJi9uvewY3aInhz8BV+6DMuAp+S/joSuYcw89uHdNrgU7M6ANzZhwnjUB4tnzra5wGNkzj9HQAc8EDOoZUi/lnuabMHt9DR8V+xGwZ9a61KjKlVmf8/Yj7b+nRUe4qJHPq65sH2S/aDksHzBQXv2ySok6l/pOnFrS4SSfvOkCY4ub1H3RICRdKhK1Z5UdK3QQ/qCWW3EdnLbkm440vwJk1bZRPuT1ZcsvUfxaAAmpbvxJs6Djah5xU/ojQMKRWBQhRrpIbm6w4RrSD2epEvq1Hbv+PVyFuFC70gYCVhc7bDqdTQZ//PO31A1fuH8UYkAh+I+Wwz4l7cxyfHHFAABquVchLrxSLh3E0C5S2acbem39VS+vBJrSR61tU2aZ/HaFZogVZ4eiY0cIqjptaE+Yj2r0bPl7bEdyROs24DWvrOpresVKWhxOF1R8Qw2SIBKPGggu1m4LLNXGpyDDO+DZ+1Gs+MAipmEBEqkMhgyc0Mab2YcU5kDB0QFo7rtKUhKZg0BenrYiu2/TG4BXz1lUINmvas6ZSa+EdLJ4zVdhrdBASRTesEqspqB+fKQ3U7jKFnmXh76jYPwCbsHggogHM42KPiSE92A4FToPGz9Sw7Ha37rXkCcXbYH368bWP/6UonLK4leaKIjIl2JWdWjNhydE2WHtBTgzAmPogVFYNrIrVtd0vjd7Qw79JT2uc4BkCF2iXbkoSYLghXYNVb3u13C1gAwmkQQwK4EDKMSfJ3ygnzF1rVT+bCKrPGZ502E/olBsN6YxKvOvI5P+bKGcwoWQ20IJDwbG+NC4G3eQXB9R9kZuSqKAQsBE5EHKAoLSUfn/KhyS8yFQJ1z1jW6atuLEeYbtgnT8sNw4mPe0Wyt6ydPlV8DNMzkDzWROl9N8LjJ3wOmtfuoXvCJpSGKRrpX1sw0VRVDAi/KnomPjUkRfsXCU6TEnj0zK9shAMdZ/wP1jJjebrIkWg8/AwQuQdK5QTVd4khnyJkUsXAYlbunITekST+GW1pwPuVTtRVbX4hZYDLfqbDSuhxkfLfGr1Uj0K/6UAQ/mi8pL6Xkgqy921VLj2m0FKGqWbvWsriDBhj0F0mi5MaujeY655MwqPp+03q31SAfKDrytewVAqXhExC5SeHwiVyYiZok1oSdJdLo53Gs1GdLuqfs586evnEkx/tVjGv+IiLvHvByU5mUAF2Mf/oVDAZ4X9v1HRJN/MIxjAAABUE+oD28t2tb9hrtCGio7A7tem6VDBEJWh8d6qMp2MXTmKLgZ0vZhH+doUvvskqnX2NAmXJFsWm3C1TaGV9QKmmhpEJ8V+nlWlH9udI79qTW3wVFrEe+/zO406xq3yffWvt/MVsgi7wWdLScouhMdjcluBSAQA+6QLctsDfD9XVMfuFiw2BlPND9V09ZFIGKDHEUtAr/CeQsNfFBttlwE4N+rovm6W3epoH8MSCTZLQg97Z5kbCzCN3P1iMO4qX4RL/VcE2HDm2goG2dpoNu++/zRMSPAThW4AY31uY4jmzxH+xFlT7kbB0aj2hIDHN05g4qk7zmzf8AYkK7UOf0jsRzSeslQoOOH32BUb79kFVV9ISd6LjoBtahyI51w57Xpsg8RWG8YC1LpD0547DUiJS2hcFNh5Lz1JGtchZJVy8/vHqwPRzSeslO6NPmzLxyomcpQ670E28QCFaVvxiF678+7xH8PVuatNhDw6B6vDJlDCVq5jQvWu/YoPkA4+Bjzg17phHuRUh75gkPHfKkz6pEsWFon3Y011jZy8Ufqfg3nOXWmhxtFgMbdGg7lbuYeMhO9LOue831BG8KlqiZs/sklX8eP/Lg4RcS81T5+HVEgmfOFLhXZ3bymYlQFkRhhyeaeUL5jLJOHwF1rEDTXM346SlwCRXx5eeeAeDwY3k80DoVCWUnF3AXABQz6t0L5DfnR2xp8S1Wq6H+rbnJGti+fP2TuqJxM8DBNrFgwEz/iWy03+nhPeoP9XcuvRmBDQGwq6q+VvsFElFXwSrjvnu3hrSaocKDx73amNl2GkNHb0fe4VpqwzZHeqqZmhP+hc5RF0rQK/JzW5JSV/MKSAojwDg2JuJgEHephKYeKaKSfGzQyTWUaxREamwnLuo9qwFkNi3acA5BhYjRn9EYFw7LR8CpCBzteV85STvtxbHY3KB+RUP5tuzTZy1OxIg7/gsIRpGnP8KMCvYlRliYNRM9OnVCN1rjm68L12ymTypH2xruTTfcx7U9UtGHcSymQ4sSx7Zv6q47izFY3/WFSpbKfPVZWqjpYFpPuhNapCmH8YaEm8n9pUx/CeXAlKDQxd/JfVPpztjJCoGHHWnwKN9AheRaQBVw4dFIyVj+b4dlrJVReOUyHaofrDi0yqgoJTMnVr+9trD3WxVAf6jRK54xe+TWuZhJMwP+pulLMFzMMIGZ3K6D4O2JKPaqgoaDxa94zqrfmaCLn26jdMvZrQh6XOFXYO4N844ThJqWMrs3gVJxB79+vPRqMpLPvojuqHUpe4X+5bVNoZX07Fad+qajFZya9JTjIlbzxWc5XQaflKd4l2G3gGZfecmOBya9B4S+WXehFsXSo0zoRccmKH9aJNHGZVJW94R6um0aXAj3kQbx7Mu9tTUOdp6rYRxq9Kvvzs/X0L40JQZwJnt08VEE9yi5qfa2rTnU+sveajxJ6/5vP+bOsIgCWOLY4OXqj35uzb5z5JQ8kU87B77T8VBfjTCxbCDk2LHVzlPIKa/ZuIgXFhsq+AhGTbnRt7toId7xNxVoBgcZBaqjHvlkjmchXKxGtdnyhYPgPUZVB/gDLXimWaT0kmhzcQ1aPHM/mTefS4DK3Ly2NVRhno3Hnf5/QsbVJYlWGDOijS+wupEe11Tl298KXgHXwWiIyty5/d0x9mLedgSdp/yuxkL9PirZHTJuzTYQ6U6AsFvQUg2TuYx7tADGKZ8R5tBchyJ8sSiukZSAxQ/0Rz7e3qaddTo7lPMdHPn9Jaqd2s6xkwoZJe0c2owx+J+4hwvGgKk+/wnj6o6hemUIGXTh/ofZvhaV8E5d319vAqIZQZlyjVfso58WDhoDHDI5J3dTf1C8r3jRnhavdk/yzj1zw1Pg5EobsGpDxvPA3zGC4ZOOHE262Gg2zzknCo8qNnQo+kRtv76W8FoOHm4vWfiKhHuMAc78Bqfd2g6JgCgKqBr06RZ4odzdzdfii1B3YPF3VXriD094pnH3pvpQKXHp+IaUl/cfZqs/KVR9Bq8Y4okSWHzF1RIKRlBXKLBbNj52K3qO0Wv2yqMTE8GRa66o9Wec14a+L6LM31qdKUIqpXny+OKhbETT+yW5H2l46gEZP2jx267ANFHdrrD5nWSkJAE04Mt+wQGGqxNGibScffbjdeyFa0LJgh4nZ5i5GQxCtgM0mAY7B3qlGvWvUsig+sKgueOuXu4P3Iu87oo/QhL/I5sYroseUdBvHggaNJa8P9dA7mK2Lj5y+TDq6uBieyJs3teiaF5dSeTMlFTPKpeK7wFYOJIXRHegQ3UoLWDhQdq7pIosukk/ed0+jyKwArM6J31kqsIfjyB3hq/5Nkt1LgpH2l46gEZP2kG8uXszseETGPBEwJmqbWEKRL095C/i0fz0qhvG2NeJR2v4yP51HRbV6r8lXltKxkaMPGWb6xnJxrEiSFdXx1RJqein1N1ml7Hb2H/Zzdp/E2muzp6fAaJvB9kw+zE8BmnRsv8w3TVS4YIu/SWwYy5BQ/6MERop4VXsvZaUmOXE9UfZmAnd0NLiO4mg5xluC7F0+vB16ZUwNhNC2TQmbxH80z6UX4Nt4vI5jX6QRv/4oTGQ8TOWAlOErIL6nUZ9SDoogeUKhJAQBKNIvYm0hPtz2ZVuoEUZHMXhSbNkRBKJHIN3HM7x3oiDXeYr/yYza7Z+09rCliRLg6gpumiTBa+kGU1CzuQUk9+HXs5vURecWZaTM6rjIx2mm31VUuY0nlTm9bx6E0e9P7JR1wSadDRuZx9TtEhkml3z+UV591xyPfpK0FWweMIRNe5IsJuaP56zvd9jUwMvdJ1a9OFPUm/faPOln6hliaDWncTe8JFgOwmKwLAehda52HvSe99wlucD+qgXUyJWG38asrOQzW6voavuqVvBfCH1Pso1Kt6MIZCn3h2pcRSFgVFo8IsWWep8OWF5KsRk8Z768RqRMtuckbFT8Co87qAfOwetz3Rol/a2Jhe3O0S+5u5uZ7YoMcRS0jePPq5KZhOH0N6DlpH7mM8aVlZ3bOsQ/IEfcOnEHr2lw9CJINGQV8j7EJpB2KGuasZHgI1D47Xbu07WcTHQSkJZo62oQLpw/nQBndXw0zs3+Bku5XPIEqNz0x9EYYdC9eRqzT1aFpYsFA5SkRrhSpJUl39zUCmWizZOOV+bYwP99HXDp9FBndstEyVN9A39IZWBEzWdiU16JBptwR2r7kWIWupNQ1IrCwg8poWGW5SLhtCSxqj/0YNpdKs91ghLUh2BrXtVn668s7srGkqi7XllYWidUUrIpalkRFBK+hZdR4Sn/rtjSelCOvl4hFXp7gZ8go8pM1osXSQZxJpwQ3WB2b621oWS+chchXZDEg5aR+5jPOiJk+cUx4sY9wqWotnD7e7fBlBkamK9dl0UncoJxHy/ydBwaPeJIkck7VG5tKm+gb+gIzMZjq9mj3KggIKCVEwQZKU5ZwJbAbofHXlN/CyIK0i4s456itQ/cWHY54aoL8Fa4Yu9+B1MNrwbBn0HD5FsxmA/a/YIxpvLtadgO29TOfTCygZBnFqMLmYXng1omBNds5BYse7b44FHviM4qWpU+/a/vaWQ0BTrENWBeJY30sCrGpSrZUtizibsFnl/gPN21HJxIyMLFeJXjFaNLOLad7IplO56RcKkx8Vs4joRclEkqIexE409zaMAaZjS3ppLEwNmpe7vVMG3GK/QPEVptsm63UkKgyRSQY9VfJ9kgbuN7//1bbnQlYrt3BouV6mFnADo3c+STOVupuf9mMEr8+SQD0+PdJuFuKjlmP9BX7aBpzfzLyIE3qvQR8WanCpMfFbOGNJJkD2ciGk9AsRIwwD261CRVRYP6IMwpA9pgHDN3Dj+JzAMn0ScDdhmd2WgXxHmAecD5DpSA5xBK+7u1PKu9B9zub8NSAymNd8uBBCs8uy7Hdp4uW5agW/NkMA6PtFFsdXHBUxu56VXhZD3pJL+/MypRQocVKHNbgZPQ1zUSjdb3BD1YSlqMrTzEu5dJezuhqG1l/noSnVqzTp0AFABDplRlmOJp23Gsx49ue2h8MvrjYQcubOd24EY5ijpjUaGGq4UqCb4EG+MgDuQ12Wp2uc3tlt6mc+mFmqx6TY1Zp+7o5m2MeIT0AR4rw6By2FV8D0D6HfHITVcY0BEwZhDMq2rYuKtzhuGLDKywFW5ptin2AbwAXR1fkbhxgCDElRmapu7ubriu1plfYG5wc7nJRgUPmuJx/tjXBdNLZhgVXt1soIyq6FscDcBYH/Cz7tC8RHob6I66qLqPWW2vKkQGoPSmKUvP29LMbIRVoV6kOacps0R84cXtOjdDJdE261pOl1RikBAEFDfqGABVdv1ok1nqtJpiptE7hkA+38RjIq2a5qq7DRDnhvNXage5h46lBsW0lzzlT24jGlG2UpxvVzIDvsR0V+lAEP1UjWLWfBigFc+Fxixm2/PJGa7belAEP2hrAQj1shWMwZYMnpuwkFjYdV3ERx+ekyGm+IIMroNFRWDayK1azFfG/qhGNwrcJ6jZ+F4RWCdnOq8nNyOmub5tNNj5mMr2xWWj5JperGVqXBIJcUJXHT0VTsOm89H2H8UEpN+rqLT+vEpNqwosr1MLZMEI1k+J3qSij4btCQGOy6mhBygKCzGcKlhuw0kCjErXDF3vwS1vIKG/UKwqYXzBy0j9zIfAiMmzvEbtk20fy3l5hIg9MFl8QWGkuY95T7/mQnQ9+SEZ7/9TKyVKCcXbsMPA9HNf9j6nI4yxPCjUA0PcvtpC07Rr8Sb267dyW0nC/R3CW8ZMC+arsGDl8b/EuhpBLw6PJsJp0ZtaasAb9GsuqAjhyJMkMsOlwo/fvlQ2yNSqvTVixrcxLhcCJb5hR2WdYPk8ExKMPGneKzJoomlaY9SgW5ocjhwnzYaKE+GUFf8twrf4tX/a2JPqcqK7BVik8FJsfYKgEfjVzcHGgKxI4CkzudErY3RjvDv4vEDnm0cb1tlvMNrwbBoGIVhIckXWPBUnaoyyfucFGqTZ5Te1MflNtC6F97RBg3dMeq0j9jKq0vrBrPUeHyQoyZxLej8Nw9w6WxgwlFD9MBN0fvOTCcd6mc+mFr/KZCY5z92nLgAbLdA1mds4Y1ZFLx4kS8l2sOd1c7DuItfnPmRCfgG+mCTSe/hLSsOE9CoevHsKvBOy36i7gLgDK2Zgkw9Y3DxsWtPf3fMHHnjWIxrfBSBWl/ZQmOjbGfe5iIaG5PPSYYYFv4+48hMtBm8xR73b01+jY8VupRwCU77YnEHHsPWK2Ljs7z7yxHgM23UrarHctYuVe6XlRr4IqC+83yPaq1YazWqRogbKYe+jdb0Gv+c9PE/ta/QCiuVFvvgQW/qqXzIgcsxlaSVL9KnXH6cu/jYPawqlnwlKILYIjJaFhfcGo+Cexq15njF+qXhNEw5HiIs6YF+8U/38Gi1zIL70ocOvJFbMB6aXssRqi1AeulROGXPnPdv8LQQqH5KX16wSA0afxvOI1NDqcLOTGvsqNm97R3vIcEIXLxPFf5vfllztBgZ27ExuQejMA3YmVarp8G59og63o9RBroSQPiWCzGQehXoDNDaKqMbYgWirktD5F+SdHNpXFaGIwckey17J9q67uUEjqDTU/tB5KbkY0WEXhl+LKA7I8+Jb9+E9HiEFrhr+90jXgGJsLok2a2K5dEB3LBV+tjxXeOMEloBgA05rOCK9KDAiWD90f14xKlhuw0kGQ9sWu5Bt4lZt4gEKzDS7t7/akR8szYnfwmAzrRVnIFP8UjcMiVIlR4wHUhG2HS5gtPwZaeLznuAO1bSPLzTSFBUqOAhqDDHaYkMZ3vckSMPTWPb4sgIkm1tt7cXLetZf9o7WAiD6r60D0lfmmfSi/BdIQVSzzZOkqX7IdFK8omgEppuBzMNjSe9xIgo80oUljEgIRoOjl1q7MI7rBFjfqU+fGkMH9ZZ2iZYNzS6lBGfssB7TPXKijxz13URYXuNqFVYu4WQgl1YU76TfmV1E0Q4gT31VjZpik6kpHsl4dMeGudO4fxjoMYzhy+KaNaaPdKQXiBHDWUp5VCPbHwc9Nead5CEfyo9HQiwjCiSNa9aGi52rTR9meQe1I6347MuhB4xJ9vy9WofY4kivZCbuyF4VGbrsDM151yLcVO9YEscaqiLGjCfX3X82vP/o8Y9oZ5khjkAVsC7grLNQFbOxvnldDV9xupXHkuyblGR4uNoS+YD+/JzxARAFP61tx5t/haFevWCP8qmYrCXTvzar3rwpKSZ882CB2hpsjbHAVL1sFhvbq0zkRoPgzBqccA5cypX3oq0CKH5W1oOa/5wAOe6MEHugVrtC5+aQjWWJEpnvyNw4wIF0ZE4LzwN8xguGT6pw3BAqyIK+E/WhtJAR100sRe6y3K7BbUYlssEael02cUSkEOqDd+0xJ/xO0qXD+KHXEtAn0ZjIisSf8TtKlw/iQE9AMV3xk83A0JJ46LDn+hTdwj2WvZQH+hwQqc7JkiQ2tKYUMIhoyO34PJrt2kTTtw8Fbru1tDGdR7TX54NEvnWKi3IVYOHnDtEiqfLSIKPhwVYRaqnI4yyYlVlRuQEvUc7+Hzia/R8yUWIpZDirDtzyy04d9kdAeYYNrJqIxpekORqeFB64nBgF7HfRMamjB9FXclpwLq9VKu2c3FWlsa33ezafG52a4r29lG6HXN24sn7UkeGkeIC6HKODpindFzEWaLJQw1o/pzLT2jyvU5DkXbFhA6vYUGYWfvMMG1k1w1GmDO7yW3/3Qw0dngDo3UrjyXZNyi5eiVBy10zQ6py7bCVWdpwX1ZzIOOLZFzGM5CbD91h7t8i2YzAgZZFfsRsGg9zkuqG6X6zH5NZus0P1uuN6WAM53svyNi/Vu1+Wngu7mP/x1uFz1F6/9JWM4Fhn8jknn6kG/p1FNHc4HgFeI7XBEEgBhlN5+WsEG3r4Isz8V+kT0OMzti+gMRir7XnL+ORrdBEuqHlAKEAIGu35Ywcg3ckGpZn+yES/1/tt/8BEFKUVfyu3hLQaDvOpPKWaqqTTApxdHvVgU/SzdpDnL1BwWQbADCTZb/CePqjqVyRJ0ELLAPTuMzpvkHqmy+pHdlRf/D7Om/CqhDI0xVpFbCLIjvZCEY5JaG9vNNSHhHBdbdlddGn7iYrsfbc8ju/BAJel4Ku9KZ7dY+/nwZod7IMFMYSVbcye+Ycsj6yqY0Hf/gRbP5fzOEP2ZUTHqWs12S+3f4fYzbg8SnOkHBQxdedddUdTjuIjVVr/qLhgLGfgC8bwme1GpS3WsKWcMVeutmUqZZFOUuBtpC0iUIPT2WKISNfT9busKsmyMLsUQ7Ur4MSfAmj5hWpk9nZ98nMMV0hUwF/vTYqJTnMfJc7xkguse75FsV793U04ubpgALxLE2l0eB8qYSnDEeoHbxKkHmh3tkA8xKYm8JQayvJN/ZQJBsT3T4nuDggqQEz/YWMu/BITz73ILf81zr7Woqa703nC2ZKov2CRkqfCmfOYwV8UkYMl89IokZ4q4X923nbeEY/WJium1QPH43e+RSHF88wWheL9mjuf10GwVJ5am+9oHqbEAEYR8pFc/XjT3ML4dgGP4O4Ns5rx5zZzkL9e6/8b9LdCZnjK4aMk2l083YAzVQXnH7Qt8PvdZrNXdkZLhjKS7KtPuydxvTo84wnRN/B1Vwh25k+EXCks+FaCK5YJqHbo0CDoP/cMYxXE29BT0apK4dH6NchM3Tk6WAQl69tvAMfRyeDF6+oYKww83o88najGOjkyojsOS4S8FgAiImXkA+aXltaXj8E0Zr4hhhTseFKp92goxN0cCnOzHdB1msYM+2hPdaWMMcuGM0ear+uX2VzgjyKl5CNGmOmCPeZaQ90KMay4bMZAcNGGyZ0RLihOhOsKc8p9OhT16a9d9EqrS5bX1c0FiSHSzstGVEymyyN0G4xMcHGNChyOdqPACgSRbTDeNnKwlPE/RhVbupA4mDw8N8ytsmSWIU2Vmmdos1QElu+83KeSglxPzhudl8yZUTUPESz03LrMJtmAglE8i5cp04/Jjq2tw+7vKWEX+Y+ASkMMS4rfHJefMEEa/oTHtDgQ6pItHBXoJ6c96mn6iJVNomKd6eJaineQb5SXv6D2VwPN4Vm6S2hZN2jZ5KtZBustfvgZzoT5Wi9hlkiFEJPM3Ww6HhUSq6GEd/LbKyGI6rpotHnGzoFq7uaN8hMUc2guF0Wl2i3VDOAUa6srgcmG4+fc4Lit6wkVvx8Udq7KnIIuMSER4Ul1bVuAo816YRrSVDJJafqS9SZYdDl5pMkdf9MYA6ev178pN5StZSD0oLKa4a0xEKLA8VW8RvoxXaptDK+oTxxkbSEmRGAS8FCPEXJRJKiHxjSiYx/N8VYnFSE5bRlx+DlF6JGc73pDcKUPLBN3IAlk43F1aYLgdT6FkWSIhdUqp4j2I8d5bGx0wKJNiu3JV6yy4rrz6MT+9ROv4Wavcoh3SKrBgAupSVjOFJ18vWl3h5vC8RotdxFJdVYldtPzrL2L++SLnztp7mcbb1dgX6ok1mYQWi6N++Gy7VEDz1R+YTEyrhXyLZjMCBYbXldgtqJPRWis6a1hsBXrSqmBsoZNFUa4SMlub6gM+GmlhCm+Ryi4I3TsXP0/JjyFJqZczahUmQPZyOvWYTbMBBKJ4tx9qsY1/xERd7MgdA2oZlqBj1HRJN/MIxtdDi23WdGQBQgTdvdEUwJpKpOfdvNY/mYHM0/8ZyTSva4mJO3aTW5/T5r0Ff8RkZRHVLp06GRQoXBFmTaiuRehhpiPmcvdUdv5A2VuuglC85Ukyt1lkStGoacXSuW1deRFRaQAThtsZWsPZsKPNJ7mJOx0jkbFN8DT9wCOVcOgMbqyRTpHGl9Vz02t1WULM9tCiJc+XteE+AcSPaU2mohA+eC/3WAVABqGountHdT6V25NBTxQYz7lsPx9NDNYK2t90zZsDNWZHNe38GDgmtTj8XC4ka3LrZ3Q0BH3glZmrghAsNAm+duOqsmHJ7jWodsu9cmg9Or+NqYz8Y+p7vVte9ytRy3a254+fRDosbjg21273pcUbDkn6m2jpX/i8yWNTwu6WFItOgx6XfEeBEYk2okNzp4dd84ygWPyVC6mxIaPW2FnTjLDJ4dd9S05b8GRJ63/WToOsLIR4GzRSCgzIT17c4thWAFk4JVWaHzyOK5pX9DGoSkVhfx1hxkMtXE46COCzlVjgNjilrZeXcxEMhZ/izqD4ylKhKj59uLHSO6YG4vZsyXeb0QHZejQf3YWR8EZ8XODgxNs7F7PVLypW0LfOkwM9f6wBziXFg+I/SlLi35vRhIvnoEUgVcmuFmgSxPzxhbxVtXq9Ammo5eTcVPARBY8fP+rPJkbdGiiU6kCbiMMUkB7zbBV/vXCpQ5r2DSOxcfE3792RmHuDhNOmG/waFVjPjnCCXeZMxkYQ9oYescPW0k0WnKgdZgJ4ilhw9zD1HWltvmP9yUyphy7LvyF5ZLdSZ74va/ZrGomzsDNO7PH5FVus81XmTrQNxARKVHGnbCcPvfco1Kt6MIZCm0v5peKTNYQdn+CTqkuoKyHw8k4seDXFWqvBmLwyjjxli/0rpj8xSmQ5c+y8Ly3WoZVXeSHSPmr4djd1oEc7fZpF6M03k3OnHb5RvcY/5+nROp6b1shmAvLqrwb9yDvPQhpV0TLc+Fs6xD8gSAGzf45LMBO181HYaCp1kdHd0jwcpwhLw16ubg40BWJHAMCh8KL8W2/LldVnVbHGYy5W11MjD3VmPakL6LZVTpfU5xQY4ilpNzwiVGYP+lKYcJWRLxbUz40DZB7YVHiKnESLDt+Ewso1Kt6MIZCmqkLVGjRqMk68xTW9BG5nCSS2M+Ul89jrE0kDNXM0cqrDdxZGWu+r23Y5Bi6mSOB0wm3d6ZTCqmKMmvV2i64gL86UYBIAqflhi+5HGbawsPrwtE8hP4q6SOOhKwCHnAflR6OhFhGbjId0shcLvH1t28pfWJRUxGkRffEnIkeY40swbUc9jLv67pb3GvdfgTst+ou4C3/pGQvbesgngXEqx/x7OXh06svY0fS+Gfx0/PSsLbatxjzV0sA/SxyCNNbMOlK9MWIKBFBC8+s+sLtdchtChdv6h4E3EppQpBJmvsrGAFsAXvAFI//M4t9hq62DyZW0WheajFRNyDc37gFhIpGXVFmBxf0aGUSvwV4n3CknXwF6oarGoCeVuZt6y07mPH7yEVquE+okSRHgX59/qreY4agMMzGgk97htohKTE/QCCwln/Ect6ZK2tLyX2qOIF6Z6ZAbKurP0aInCtXvsAaiMKuo7euZ0YpGFDIwtM9kSb7vILRxAEZef5OWkUGMxag3HVkqKFqiC0WxdGQxPgx3U/2HgewlbRqDpCk+Q0pkrVYewaQEoYCoSAatR3kaSNC5OqKv3nNL+GHJpNrLd1oEYSlG7BUt/DwkdBEOHB5ZxS1qBKomIXba3qzKtGbZ1MWpO0qSyElFclTn7IM87v1uNyW+WhIa4lVB2rKCK3GrPVVfoNo8cQv1CVtQbE5QxCqhhGVHmT//GHVfYghRD/85VQmbrl2X9RT95X8UzZO7LbAHccpN3ySZMOg2G/gy08/PTrt3oehbQlGHSREg4KzVszmmVjzhPt16iJgXyum7o8R9oa5dc7RpOw1xzi4qkk30uwpw0GQgmbT/husffWkRzYih6LpP/SbX/H63OtwQgSweOC+CLh2QfJoPGEFcZpU/do+h1bBh729+J8YqbLzVQk4yRrt4OH5QeVHOLfMob8Vt+C+1iOUgpghexKFapLWlYWBC5JU2nzjcpD7Itcf05x1q7WVNaI7HLMqjhAQz3SNLuiY9CoVE7mgkQbxUuYHPeXrENM5je2afQWmr5DRmcU5VHoJHKElvFeX7LA/4w2LlebQ2FM8d0WA6qKwbGZoi9cw5hN3X0WKYT+jtYUMkjk0+wUPWnMttfsPXF2k8b5twAcffUZAy4Uybd8DWT6s+hEnVbC91RCVENPQ3mtHvgCXLCDrwPBMBPeiD8m+idYuSMpO6/WEHjJkJBK8b1jTqfg2peyIZLJzKl+0zRGcU7W/Eg89MVnZUciz0Q2aRFX2Hsc8ITdRZOcnI7E4Mmf7CG6/FIi9YP5IQw0M8LUfmVCYjsL6hnlgtW5D+nguFoTsvWjOjNQXTwAjBQvn1TwAa5Hvq9GLrw49LxiRP45c4sXJtqWufp/L7LfYMBohonPjP+DWsLmw4y24MJlUPQsD/vuEEuvgG3EQ12GqwxBHZLN8O54nQlbEh0pVflKPioj5R0IIqMkPbNhwDLm/NsBALv1R6peyWF330vJD/iPUEg9exNI2ww+dIss+eGNofWxyWI5M8DTnWczfgqWiKDeFhnkZu/gGXX/Me16wh/VEcedjabGmWusd2sOnQis9c/D60qsXTorcjluMnTTE6bZLTYgZl352e4i1+cg7NBvFYT1YZ70mJilhkYuAHcx/b+6G1v/kgfLafyWNKcSGCiOGqKPz6Sq0FhpIZPEitnB1d6HxRklp3FiWPaEPruHlQfyuKAMlJ3WDVNiQjxS3QptzDgHp3AbfeQvbAMHQp9OrNKAdKQaAVUDsPCGpNkqEROgb6Da7aEWamkIst/uKPtKZ9mE20BJxGFuRCKTcbSlvu//Uxysxn/I5rIRp0x8jNxGRDLedksW4nfs4H21Q99Be3IXiEflh52nHJ8y+8WPO+2I05fWEsfj6DIxt/lJbQeJ13QOd0q7Pkm9tiBEDEUtFpcYwPzGOLsvKUqlRKasjTzY/XJ3fkSN2AFcQ4Lij/CFUnX5EeyNUz1LnglP66YceC2sQ2F5o/cT9yDJqAevE1e0bXx+BLn9jsCpAYDIQrrOI41uUo+NxfqFYlSvdVBFwWSflvImE0pBbKVwuhcJcvJBV9B6WYdY4LNfC4Z6jQShhnVdq1NQ+ELjZNwueeLxbC0QP/KJAPjhilPnldC5TXI6VfEUWnXh6qpTdMQo6grUoYqFcF7ZuHjzAwZNcvJH6zpSltCRS6EhlUvA5oo5ZcFHi0LPi3WuYRb3n8q505YLlS81LZuAbUCyKQsXTLgMmzoPR7Cy5gJ7+LPkAmSFzzoNaeq+Op9dvzjBuA/2cVWwOnPCKCVc4Net/KmU+sPRNX8QsZqlaoCCxFEUYiJFfBgkVSaU571PdOX9Isew5rQn4kRP/LXuyCrSMElp+zCTHq5U0BKGEwBPRerU7276nQ3PPb9/qoAlDmQGOqkyHIPKBFBC8+qM8Kco2CznLIizqoM+3XfpZijkK1BgvCZIH83/rkdHbEf3PXiuHQPyreLmPoGRDY9kOhObT/vLhnOBg+RqqEThGw5B/jPOXaQSAAcsqQdwW3CXJhhB04V0e2s2zU0zuWAAAAAA)

------

## WGY

可以把首先把连接不同色点的边权设置为1，同色的设为9，这样整个问题就变成了查询路径上的权值和。

显然，我们可以用暴力$LinkCutTree$或$TreeChainSplitting$来搞，这里给出$LCT$的做法。

维护每一个$Splay$节点的最左端点的值和最右端点的颜色，对于它的老汉节点，我们可以找出它的前驱和后继的颜色。这样就可以累计它和前驱和后继连边的权值和辣

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define lson (fhq[x].ch[0])
#define rson (fhq[x].ch[1])

using namespace std;


#define DEBUG 1 // debug toggle
struct IO {
#define MAXSIZE (1 << 20)
#define isdigit(x) (x >= '0' && x <= '9')
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? ' ' : *p1++;
  }
  inline bool blank(char ch) {
    return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
  }
  template <class T>
  inline void read(T &x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == '-') sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');
    if (ch == '.')
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - '0');
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &c) {
#if DEBUG
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template <class T>
  inline void write(T x) {
    if (x < 0) x = -x, push('-');
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + '0');
  }
  template <class T>
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

const int SIZE = 1e6 + 5;
int n, m;
class LinkCutTree {
public:
    struct SPLAY {
        int w, c;
        int l, r;
        int tag, rev;
        int fa, ch[2];
    } fhq[SIZE]; // The fhq-treap replaces the splay
    // Struct SPLAY
    int stack[SIZE], tp;

    inline bool isroot(int x) { return fhq[fhq[x].fa].ch[0] ^ x && fhq[fhq[x].fa].ch[1] ^ x; }
    inline void tr_dn1(int x) { if (fhq[x].rev) swap(lson, rson), swap(fhq[lson].l, fhq[lson].r), swap(fhq[rson].l, fhq[rson].r), fhq[lson].rev ^= 1, fhq[rson].rev ^= 1, fhq[x].rev = 0; }
    inline void tr_dn2(int x) { if (fhq[x].tag) fhq[x].l = fhq[x].r = fhq[x].c = fhq[x].tag, fhq[lson].tag = fhq[rson].tag = fhq[x].tag, fhq[x].w = fhq[x].tag = 0; }
    inline void tr_dn(int x) { tr_dn1(x), tr_dn2(x); }
    inline void tr_up_(int x) { tr_dn(lson), tr_dn(rson); fhq[x].w = fhq[lson].w + fhq[rson].w; }
    inline void tr_up1(int x) { if (lson) fhq[x].l = fhq[lson].l, ((fhq[x].c ^ fhq[lson].r) && (++fhq[x].w, 1)); else fhq[x].l = fhq[x].c; }
    inline void tr_up2(int x) { if (rson) fhq[x].r = fhq[rson].r, ((fhq[x].c ^ fhq[rson].l) && (++fhq[x].w, 1)); else fhq[x].r = fhq[x].c; }
    inline void tr_up(int x) { tr_up_(x); tr_up1(x); tr_up2(x); }
	inline void rotate(int x) { int y = fhq[x].fa, z = fhq[y].fa, k = fhq[y].ch[1] == x; if (!isroot(y)) fhq[z].ch[fhq[z].ch[1] == y] = x; fhq[x].fa = z; fhq[y].ch[k] = fhq[x].ch[k ^ 1], fhq[fhq[x].ch[k ^ 1]].fa = y; fhq[x].ch[k ^ 1] = y; fhq[y].fa = x; tr_up(y); }
    inline void splay1(int x) { stack[tp = 1] = x; for (int i = x; !isroot(i); i = fhq[i].fa) stack[++tp] = fhq[i].fa; while (tp) tr_dn(stack[tp--]); }
    inline void splay2(int x) { for (; !isroot(x); rotate(x)) { int y = fhq[x].fa, z = fhq[y].fa; if (!isroot(y)) (fhq[y].ch[1] ^ x ^ fhq[z].ch[1] ^ y) ? rotate(x) : rotate(y); } }
	inline void splay(int x) { splay1(x), splay2(x); tr_up(x); }
    inline void access(int x) { for (int y = 0; x; y = x, x = fhq[x].fa) splay(x), rson = y, tr_up(x); }
    inline void makeroot(int x) { access(x), splay(x), fhq[x].rev ^= 1; }
    inline int findroot(int x) { access(x), splay(x); while (lson) x = lson; return x; }
    inline void split(int x, int y) { makeroot(x), access(y), splay(y); }
    inline void connect(int x, int y) { makeroot(x), fhq[x].fa = y; }
} lct_mast; // Class LinkCutTree

signed main() {
    io.read(n), io.read(m);
    for (int i = 1, x; i <= n; ++i) io.read(x), lct_mast.fhq[i].c = lct_mast.fhq[i].l = lct_mast.fhq[i].r = x;
    for (int i = 1, x, y; i < n; ++i) io.read(x), io.read(y), lct_mast.connect(x, y);
    for (int i = 1, a, b, c; i <= m; ++i) {
        char ch = getchar();
        while (ch ^ 'C' && ch ^ 'Q') ch = getchar();
        if (ch ^ 'Q') io.read(a), io.read(b), io.read(c), lct_mast.split(a, b), lct_mast.fhq[b].tag = c;
        else io.read(a), io.read(b), lct_mast.split(a, b), io.write(lct_mast.fhq[b].w + 1, '\n');
    }
    return 0;
}
```

## LYC

# 15.「ZJOI2017」树状数组

漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的OI比赛经历。那是一道基础的树状数组题。

给出一个长度为$n$的数组$A$，初始值都为0，接下来进行$m$次操作，操作有两种：

\* 1 x，表示将 $A_{x}$ 变成 $\left ( A_{x}+ 1 \right )$ mod 2。

\* 2 l r，表示询问 $ \left ( \sum_{i=l}^{r} A_{i}  \right )$ mod 2。


尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常young 的她写了如下的算法：

![fig2.webp](data:image/webp;base64,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)

其中 lowbit($x$) 表示数字 $x$ **最低**的非 0 二进制位，例如 lowbit(5) = 1, lowbit(12) = 4。进行第一类操作的时候就调用 Add($x$)，第二类操作的时候答案就是 Query($l$,$r$)。

如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了： **Add 和 Find 中** $x$ **变化的方向反了**。因此这个程序在最终测试时华丽的爆 0 了。

然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对

拍的原因。

现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的

感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$

的值，因此她假定这次操作的 $x$ 是在 $\left [ l_{i},r_{i} \right ]$ 范围内 **等概率随机** 的。

具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 0，接下来进行了 $m$ 次操作：

\* 1 $l$ $r$，表示在区间 $\left [ l, r \right ]$ 中等概率选取一个 $x$ 并执行 Add($x$)。

\* 2 $l$ $r$，表示询问执行 Query$\left ( l, r \right )$得到的结果是正确的概率是多少。

-----

这道题$\cdots$，没什么可讲的吧？二维线段树蛮干就好了

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define mid ((l + r) >> 1)

using namespace std;
typedef long long int ull;

const int SIZE = 1e5 + 5;
const int MOD = 998244353;
struct TreeNode {
    int l, r;
    int val;
} tr[SIZE * 400];
int rt[SIZE * 20], n, q, tot;

inline ull result(ull p, ull q) {
    ull res = p * q; res %= MOD;
    return res = (res + (1 - p + MOD) * (1 - q + MOD) % MOD) % MOD;
}

inline ull fast_pow(ull x, ull y) {
    ull res = 1;
    for (; y; y >>= 1, (x *= x) %= MOD) if (y & 1) (res *= x) %= MOD;
    return res % MOD;
}

inline void modifies(int l, int r, int &rt, int x, int y, ull p) {
    if (!rt) rt = ++tot, tr[rt].val = 1;
    if (l >= x && r <= y) return (void)(tr[rt].val = result(p, tr[rt].val));
    if (mid >= x) modifies(l, mid, tr[rt].l, x, y, p);
    if (mid < y) modifies(mid + 1, r, tr[rt].r, x, y, p);
}

inline void modify(int l, int r, int rt, int lx, int rx, int ly, int ry, ull p) {
    if (l >= lx && r <= rx) return (void)(modifies(1, n, ::rt[rt], ly, ry, p));
    if (mid >= lx) modify(l, mid, rt << 1, lx, rx, ly, ry, p);
    if (mid < rx) modify(mid + 1, r, rt << 1 | 1, lx, rx, ly, ry, p);
}

inline ull finds(int l, int r, int rt, int x) {
    if (!rt) return 1;
    if (l ^ r)
        if (mid >= x) return result(tr[rt].val, finds(l, mid, tr[rt].l, x));
        else return result(tr[rt].val, finds(mid + 1, r, tr[rt].r, x));
    else return tr[rt].val;
}

inline ull find(int l, int r, int rt, int x, int y) {
    if (l ^ r)
        if (mid >= x) return result(finds(1, n, ::rt[rt], y), find(l, mid, rt << 1, x, y));
        else return result(finds(1, n, ::rt[rt], y), find(mid + 1, r, rt << 1 | 1, x, y));
    else return finds(1, n, ::rt[rt], y);
}

signed main() {
    scanf("%d %d", &n, &q);
    for (int i = 0; i < q; ++i) {
        int opt, l, r;
        scanf("%d %d %d", &opt, &l, &r);
        if (opt ^ 1) printf("%lld\n", find(0, n, 1, l - 1, r));
        else {
            ull p = fast_pow(r - l + 1, MOD - 2);
            if (l > 1) modify(0, n, 1, 1, l - 1, l, r, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, 1, l - 1, 0);
            if (r < n) modify(0, n, 1, l, r, r + 1, n, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, r + 1, n, 0);
            modify(0, n, 1, l, r, l, r, (1 - p * 2 % MOD + MOD) % MOD), modify(0, n, 1, 0, 0, l, r, p);
        }
    }
    return 0;
}
```

# 16.P2161 [SHOI2009]会场预约

```cpp
// 未免LJS吐槽不贴题面了
```

-----

这道题正解应该是平衡树或者BIT，这里提供一种简便的STL做法。

对于第一个操作，我们可以令有冲突的预约相等，避免set特性坑死一票人

对于第二个操作直接输出set的大小即可

```cpp
// 省略头文件和快读

struct LaLaLand {
	int l, r;
	bool operator < (const LaLaLand& rhs) const { return r < rhs.l; }
};
set < LaLaLand > st;
int T;

signed main() {
	for (read(T); T; --T) {
		char opt[5];
		read(opt);
		int l, r, cnt = 0;
		if (*opt == 'A') {
			read(l, r);
			LaLaLand tmp = {l, r};
			IT it = st.find(tmp);
			while (it != st.end()) ++cnt, st.erase(it), it = st.find(tmp);
			st.insert(tmp);
			write(io_l, cnt);
		}
		else write(io_l, st.size());
	}
	return 0;
}
```

# 17.SP11470 TTM - To the moon

一个长度为n的数组，4种操作 ：

- `C l r d`：区间 $[l,r]$ 中的数都加 $d$ ，同时当前的时间戳加 $1$。

- `Q l r`：查询当前时间戳区间 $[l,r]$ 中所有数的和 。

- `H l r t`：查询时间戳 $t$ 区间 $[l,r]$ 的和 。

- `B t`：将当前时间戳置为 $t$ 。

----

这道题正解应该是主席树+标记永久化，我来提供一种代码极短(压行后不到1K)的做法(怎么感觉我就没什么正经解法)

维护一个差分数组，将每次询问看作是两次前缀和相减

然后...就没有然后了，其它都是模板的主席树，只是修改用差分就好了

# 18.P4168 [Violet]蒲公英

在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。

为了简化起见，我们把所有的蒲公英看成一个长度为n的序列 $(a_1,a_2..a_n)$，其中 $a_i$ 为一个正整数，表示第i棵蒲公英的种类编号。

而每次询问一个区间 [l,r]，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。

注意，你的算法必须是在线的

-------

## LYC:

~~这就是传说中的分块打表了~~

由于强制在线，莫队是不可能的了

求区间众数，我们可以按之前讲的分块打表技术，处理出每两个特征点的每个元素的出现个数和当前众数。

对于每个询问，由于众数问题不容易往回收（要重新找众数），我们选取左右端点往内的最近的特征点

**继承**（注意不是直接把这个区间的答案拿来接着用，因为不能回退，如果直接用又不回退，下次调用时会调到错误的结果）这个区间的答案，利用这个区间之前统计的元素出现个数

向外扩张，统计出要询问的答案

最后要把刚刚统计众数加上的元素个数清掉（回溯最初处理好的状态）

代码：（这里块大小我开的$n^{2/3}$，开$\sqrt n$好像开不下） 
```
#include<cmath>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
vector<int> pri;
int n,m,a[40010],each,cnt[40][40][40010],MAX[40][40],lans,l,r,ans,tmp[40010];
int main()
{
	scanf("%d %d",&n,&m);
	each=pow(n,2.0/3);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);
		pri.push_back(a[i]);
	}
	sort(pri.begin(),pri.end());
	pri.erase(unique(pri.begin(),pri.end()),pri.end());
	for(int i=1;i<=n;++i)	a[i]=lower_bound(pri.begin(),pri.end(),a[i])-pri.begin()+1;//离散化 
	for(int i=1,p=1;i<=n;i+=each,++p)
	{
		for(int j=i+each-1,q=p;j<=n;j+=each,++q)
		{
			for(int k=i;k<=j;++k)
			{
				++cnt[p][q][a[k]];
				if(cnt[p][q][a[k]]>cnt[p][q][MAX[p][q]]||(cnt[p][q][a[k]]==cnt[p][q][MAX[p][q]]&&a[k]<MAX[p][q]))	MAX[p][q]=a[k];
			}
		}
	}//初始化（打表） 
	for(int i=1;i<=m;++i)
	{
		scanf("%d %d",&l,&r);
		l=(l+lans-1)%n+1;
		r=(r+lans-1)%n+1;
		if(l>r)	swap(l,r);//强制在线 
		if(r-l>2*each)
		{
			int p=ceil(1.0*(l-1)/each)+1;
			int q=ceil(1.0*(r+1)/each)-1;//得到向内收缩的端点
			ans=MAX[p][q];//继承答案 
			for(int i=(p-1)*each;i>=l;--i)
			{
				++cnt[p][q][a[i]];
				if(cnt[p][q][a[i]]>cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&&a[i]<ans))	ans=a[i];
			}
			for(int i=q*each+1;i<=r;++i)
			{
				++cnt[p][q][a[i]];
				if(cnt[p][q][a[i]]>cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&&a[i]<ans))	ans=a[i];
			}
			lans=pri[ans-1];//获得原值 
			printf("%d\n",lans);
			for(int i=(p-1)*each;i>=l;--i)	--cnt[p][q][a[i]];
			for(int i=q*each+1;i<=r;++i)	--cnt[p][q][a[i]];//回溯 
		}
		else//区间太小，如果两个端点在一个块内，向内收缩就会重复统计整个块，所以暴力统计 
		{
			ans=0;
			for(int i=l;i<=r;++i)
			{
				++tmp[a[i]];
				if(tmp[a[i]]>tmp[ans]||(tmp[a[i]]==tmp[ans]&&a[i]<ans))	ans=a[i];
			}
			lans=pri[ans-1];
			printf("%d\n",lans);
			for(int i=l;i<=r;++i)	--tmp[a[i]];//回溯清零 
		}
	}
	return 0;
} 
```

## WGY:

这道题luogu的数据很水，于是...于是...我们直接离散化+暴力就能过！

然后....然后就没了(这次真的不是我不想写，是真的没什么写的...)

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define mid ((l + r) >> 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

// #define DEBUG 1
struct IO {
#define MAXSIZE (1 << 20)
#define isdigit(x) (x >= '0' && x <= '9')
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? ' ' : *p1++;
  }
  inline bool blank(char ch) {
    return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
  }
  template <class T>
  inline void read(T &x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == '-') sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');
    if (ch == '.')
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - '0');
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &c) {
#if DEBUG
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template <class T>
  inline void write(T x) {
    if (x < 0) x = -x, push('-');
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + '0');
  }
  template <class T>
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

const int SIZE = 50000 + 5;
int a[SIZE], b[SIZE];
int cnt[SIZE], x;
int l, r, n, m, l0, r0;

signed main() {
	io.read(n), io.read(m);
	for (int i = 1; i <= n; ++i) io.read(a[i]), b[i] = a[i];
	sort(b + 1, b + 1 + n);
	int len = unique(b + 1, b + 1 + n) - b - 1;
	for (int i = 1; i <= n; ++i) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b;
	while (m--) {
		io.read(l0), io.read(r0);
		l = (l0 + x - 1) % n + 1;
		r = (r0 + x - 1) % n + 1;
		if (l > r) swap(l, r);
		for (int i = l; i <= r; ++i) cnt[a[i]]++;
		int MAX = 0, pos = 0;
		for (int i = 1; i <= len; ++i) if (MAX < cnt[i]) MAX = cnt[i], pos = i;
		printf("%d\n", b[pos]);
		x = b[pos];
		memset(cnt, 0, sizeof cnt);
	}
}
```

# 19.[CQOI2014]排序机械臂

为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。它遵循一个简单的排序规则，第一次操作找到高度最低的物品的位置 $P_1$ ，并把左起第一个物品至 $P_1$  间的物品 (即区间 $[1,P_1]$  间的物品) 反序；第二次找到第二低的物品的位置 $P_2$ ，并把左起第二个至 $P_2$  间的物品 (即区间 $[2,P_2]$  间的物品) 反序……最终所有的物品都会被排好序。

![fig3.webp](data:image/webp;base64,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)

上图给出有六个物品的示例，第一次操作前，高度最低的物品在位置 $4$ ，于是把第一至第四的物品反序；第二次操作前，第二低的物品在位罝六，于是把第二至六的物品反序……

你的任务便是编写一个程序，确定一个操作序列，即每次操作前第 $i$  低的物品所在位置 $P_i$ ，以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。

----

## LYC：

我们乍一看这道题

“哟！区间翻转平衡树裸题，还6倍经验？！”

再一看，每次翻转区间第一个到元素值最小的一个，再删除最小的一个

？？？

元素值最小的一个

应该怎么维护呢

我们可以在update里顺便维护这个子树中最小的值是第几个和它的大小（我脑残维护了前面有几个数）。

针对这个进行分类讨论：

1).当前结点的值比左右子树的最小值都小

那么最小值是当前结点的值。

它前面的元素个数是左子树的大小（中序遍历为原序列）

2).左子树的最小值最小

完美继承左子树的两个值。

3).右子树的最小值最小

最小值不用说了吧。

它前面的个数就是左子树的大小加一（当前结点）再加上右子树中在它前面的元素个数 

因为子树不变时，那我们维护的这个值也不变。子树变了，那就肯定要更新。

然后再每次都查询最小的元素在哪一个位置，删掉它再翻转前面的区间就好了

代码：
```
#include<cstdio>
#include<algorithm>
using namespace std;
int n,tot,root,root1,root2,root3,c[100010];

struct node
{
	int l,r,num,key,sum;
	int s,smum;//最小值大小，前面的元素个数 
	bool rev;//翻转标记 
}nodes[100010];

struct laji
{
	int v,ID;
}a[100010];
bool cmp(laji one,laji two)
{
	if(one.v^two.v)	return one.v<two.v;
	return one.ID<two.ID;
}//离散化，顺便解决如果值相同，保持原有相对位置的问题 

int newnode(int val)
{
	nodes[++tot].s=val;//最小值设为自己，前面没有数 
	nodes[tot].num=val;
	nodes[tot].key=rand();
	nodes[tot].sum=1;
	return tot;
}
void pushdown(int x)
{
	swap(nodes[x].l,nodes[x].r);//首先交换左右儿子 
	nodes[x].smum=nodes[x].sum-(nodes[x].smum+1);//整个子树翻转过来，则最小值的位置就要翻过来 
	//原来前面的元素个数：nodes[x].smum
	//原位置: nodes[x].smum+1
	//翻转位置：nodes[x].sum-(nodes[x].smum+1)+1
	//翻转后前面的元素个数：nodes[x].sum-(nodes[x].smum+1)
	nodes[nodes[x].l].rev^=1;
	nodes[nodes[x].r].rev^=1;//下传标记 
	nodes[x].rev=0;//记得清空 
}
void update(int x)
{
	nodes[x].sum=nodes[nodes[x].l].sum+nodes[nodes[x].r].sum+1;
	if(nodes[nodes[x].l].rev)	pushdown(nodes[x].l);
	if(nodes[nodes[x].r].rev)	pushdown(nodes[x].r);//如果左右子树有标记，也要下传，否则更新出的值不对
	if(nodes[x].num<nodes[nodes[x].l].s&&nodes[x].num<nodes[nodes[x].r].s)//分类讨论情况1 
	{
		nodes[x].s=nodes[x].num;
		nodes[x].smum=nodes[nodes[x].l].sum;
	}
	else if(nodes[nodes[x].l].s<nodes[nodes[x].r].s)//情况2 
	{
		nodes[x].s=nodes[nodes[x].l].s;
		nodes[x].smum=nodes[nodes[x].l].smum;
	}
	else//情况3 
	{
		nodes[x].s=nodes[nodes[x].r].s;
		nodes[x].smum=nodes[nodes[x].r].smum+nodes[nodes[x].l].sum+1;
	}
}
void split(int now,int siz,int &x,int &y)
{
	if(!now)	x=y=0;
	else
	{
		if(nodes[now].rev)	pushdown(now);//下面要用到它的儿子，所以我们要下传标记 
		if(nodes[nodes[now].l].sum<siz)
		{
			x=now;
			split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y);
		}
		else
		{
			y=now;
			split(nodes[now].l,siz,x,nodes[y].l);
		}
		update(now);
	}
}
int merge(int x,int y)
{
	if(!x||!y)	return x+y;
	if(nodes[x].key<nodes[y].key)
	{
		if(nodes[x].rev)	pushdown(x);
		nodes[x].r=merge(nodes[x].r,y);
		update(x);
		return x;
	}
	else
	{
		if(nodes[y].rev)	pushdown(y);
		nodes[y].l=merge(x,nodes[y].l);
		update(y);
		return y;
	}
}
int main()
{
	srand(20060515);
	nodes[0].num=nodes[0].s=1e9;//处理节点为空的特殊情况为极大值，使更新叶子节点时不会把0更新进去 
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i].v);
		a[i].ID=i;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;++i)	c[a[i].ID]=i;//离散化 
	for(int i=1;i<=n;++i)	root=merge(root,newnode(c[i]));//处理原序列，直接把当前元素插入到它前面元素的右边 
	for(int i=1;i<=n;++i)
	{
		if(nodes[root].rev)	pushdown(root);//如果根节点有翻转标记要翻转，否则最小值的位置是反的。 
		printf("%d ",nodes[root].smum+i);//还有之前的i-1个已经被删除的数 
		split(root,nodes[root].smum,root1,root2);
		split(root2,1,root2,root3);//删除这个数 
		nodes[root1].rev^=1;//翻转前面的区间 
		root=merge(root1,root3);
	}
	return 0;
}
```

## WGY:

SplayNB！！！区间操作直接秒过！！(具体题解参考LYC，我就放个代码)

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define mid ((l + r) >> 1)

using namespace std;

// #define DEBUG 1
struct IO {
#define MAXSIZE (1 << 20)
#define isdigit(x) (x >= '0' && x <= '9')
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? ' ' : *p1++;
  }
  inline bool blank(char ch) {
    return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
  }
  template <class T>
  inline void read(T &x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == '-') sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');
    if (ch == '.')
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - '0');
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &c) {
#if DEBUG
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template <class T>
  inline void write(T x) {
    if (x < 0) x = -x, push('-');
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + '0');
  }
  template <class T>
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

const int SIZE = 100000 + 5;
struct SPLAY {
    int fa;
    int size;
    int val;
    int rev;
    int ch[2];
} t[SIZE];
int n, root, tot, pos[SIZE];
struct InputNode {
    int id;
    int val;
} a[SIZE];

bool cmp1(const InputNode& rhs, const InputNode& rsp) { return rhs.val ^ rsp.val ? rhs.val < rsp.val : rhs.id < rsp.id; }
bool cmp2(const InputNode& rhs, const InputNode& rsp) { return rhs.id < rsp.id; }

void update(int x) {
    t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1;
}

void transf(int x) {
    if (t[x].rev) {
        swap(t[x].ch[0], t[x].ch[1]);
        t[t[x].ch[0]].rev ^= 1;
        t[t[x].ch[1]].rev ^= 1;
        t[x].rev = 0;
    }
}

int make(int fa, int l, int r) {
    if (l > r) return 0;
    int p = ++tot;
    return(t[p].val = a[mid].val, t[p].fa = fa, pos[a[mid].val] = p, t[p].ch[0] = make(p, l, mid - 1), t[p].ch[1] = make(p, mid + 1, r), update(p), p);
}

void rotate(int x) {
    int y = t[x].fa, z = t[y].fa;
    transf(y), transf(x);
    int k = t[t[x].fa].ch[1] == x;
    t[y].ch[k] = t[x].ch[k ^ 1];
    t[t[y].ch[k]].fa = y;
    t[y].fa = x;
    t[x].ch[k ^ 1] = y;
    t[x].fa = z;
    if (z) t[z].ch[y == t[z].ch[1]] = x;
    update(y), update(x);
}

void splay(int x, int goal) {
    for (int y; (y = t[x].fa) ^ goal; rotate(x))
        if (t[y].fa ^ goal)
            rotate(t[t[x].fa].ch[1] ^ x ^ y ^ t[t[y].fa].ch[1] ? x : y);
    if (!goal) root = x;
}

int behavior() {
    transf(root);
    int x = t[root].ch[1];
    while (transf(x), t[x].ch[0]) x = t[x].ch[0];
    return x;
}

signed main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i + 1].val), a[i + 1].id = i + 1;
    a[1].val = 0, a[n + 2].val = n + 1;
    sort(a + 2, a + 2 + n, cmp1);
    for (int i = 2; i <= n + 1; ++i) a[i].val = i - 1;
    sort(a + 2, a + 2 + n, cmp2);
    root = make(0, 1, n + 2);
    for (int i = 1; i <= n; ++i) {
        int x = pos[i];
        splay(x, 0);
        printf("%d ", t[t[x].ch[0]].size);
        x = behavior();
        int y = pos[i - 1];
        splay(y, 0);
        splay(x, y);
        t[t[x].ch[0]].rev ^= 1;
    }
    return 0;
}
```

# 20.[SHOI2013]扇形面积并(权值线段树&扫描线)

![fig4.webp](data:image/webp;base64,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)

给定 n 个同心的扇形，求有多少面积，被至少 $k$ 个扇形所覆盖。

-----

## LYC:

这道题要用到扫描线的思想,那扫描线是什么呢?

**扫描线**：

经典应用：给出一堆矩阵，求它们覆盖的总面积

数据范围~~恶心死了~~，$10^5$个矩阵，矩阵的坐标的绝对值小于$10^9$。

看到这个数据范围我们就知道：要离散化。

之后呢，我们把每个矩阵的左右边界都转换成添加和删除。

我们用一条扫描线从左到右扫过去，线段树来维护现在整条扫描线的被覆盖情况。

矩阵的左边就是添加以这个矩阵的上下边界点为端点的线段。

右边再右边一个就转换成删除。

每走过一个点，我们就用线段树统计当前扫描线被这些矩阵覆盖了多少，再把答案加上去就好了。

模板我就不写啦~~其实是我不会~~

$\ $

好了那我们来看这道题吧。

一堆圆心相同的扇形，求被至少$k$个扇形覆盖的面积。

我们先单看一条从圆心射出的射线。

由于每个扇形的圆心是相同的。

所以覆盖每个地方的扇形数量是向外递减的。

那么被至少$k$个扇形覆盖的地方就在从外到内第$k$个扇形，它被刚好或者多于$k$个扇形所覆盖，更向内的地方的数量则更多，也是大于等于$k$。

所以我们可以用权值线段树来维护每个地方有多少个扇形边界。从而查找从外到内第$k$个扇形边界。

运用扫描线思想，把给出的扇形的两个角度值转换成添加和删除一个扇形边界。

实现有很多坑，自己看注释吧。

代码：
```
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
long long n,m,k,nodes[400010],a1,a2,ans,s,now;
struct cir
{
	long long r;
	bool insorex;//1为添加，2为删除
}cur;
vector<cir> op[2000010];//用来储存在每个角度的修改
void ins(long long l,long long r,long long x,long long pos)
{
	++nodes[x];
	if(l^r)
	{
		long long mid=(l+r)>>1;
		if(pos<=mid)	ins(l,mid,x<<1,pos);
		else	ins(mid+1,r,x<<1|1,pos);
	}
}
void exins(long long l,long long r,long long x,long long pos)//权值线段树删除
{
	--nodes[x];
	if(l^r)
	{
		long long mid=(l+r)>>1;
		if(pos<=mid)	exins(l,mid,x<<1,pos);
		else	exins(mid+1,r,x<<1|1,pos);
	}
}
long long find(long long l,long long r,long long x,long long val)//权值线段树查找从外到内第k个
{
	if(l==r)	return l;
	long long mid=(l+r)>>1;
	if(val<=nodes[x<<1|1])	return find(mid+1,r,x<<1|1,val);
	else	return find(l,mid,x<<1,val-nodes[x<<1|1]);
}
int main()
{
	scanf("%lld %lld %lld",&n,&m,&k);
	for(long long i=1;i<=n;++i)
	{
		scanf("%lld %lld %lld",&cur.r,&a1,&a2);
		s=max(s,cur.r);
		a1+=m;
		a2+=m;//a1,a2可能是负数
       		//转换成添加和修改
		if(a1>a2)//这个扇形跨越了分界线，需要拆成两半
		{
			cur.insorex=1;
			op[a1+1].push_back(cur);
			op[1].push_back(cur);
			cur.insorex=0;
			op[a2+1].push_back(cur);
		}
		else
		{
			cur.insorex=1;
			op[a1+1].push_back(cur);
			cur.insorex=0;
			op[a2+1].push_back(cur);
		}
	}
	for(long long i=1;i<=m*2;++i)//注意是半开区间(-Pi,Pi]
	{
		for(long long j=0;j<op[i].size();++j)//进行修改操作
		{
			cur=op[i][j];
			if(cur.insorex)
			{
				ins(1,s,1,cur.r);
				++now;
			}
			else
			{
				exins(1,s,1,cur.r);
				--now;//统计现在总共有多少个
			}
		}
		if(now>=k)//有k个才统计，不然容易出锅
		{
			long long tmp=find(1,s,1,k);
			ans+=tmp*tmp;//圆面积公式：Pi*r*r
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

## WGY

提供树状数组+二分做法，复杂度$O(n\log^2n)$

~~树状数组写起来短，常数小，动动脑子可以套在很多题目上，它不香嘛~~

题目让我们求目前覆盖的第 $k$ 大，我们可以把原来的覆盖位置差分一下，然后二分即可

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define mid ((l + r) >> 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

 #define DEBUG 1
struct IO {
#define MAXSIZE (1 << 20)
#define isdigit(x) (x >= '0' && x <= '9')
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? ' ' : *p1++;
  }
  inline bool blank(char ch) {
    return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
  }
  template <class T>
  inline void read(T &x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == '-') sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');
    if (ch == '.')
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - '0');
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &c) {
#if DEBUG
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template <class T>
  inline void write(T x) {
    if (x < 0) x = -x, push('-');
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + '0');
  }
  template <class T>
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

const int SIZE = 1e6 + 5;
int n, m, k, a[SIZE];
LL tree[SIZE], ans;
vector < int > In[SIZE<<1], Out[SIZE<<1];

void Add(int x, int y) { for (; x < SIZE; x += x & -x) tree[x] += y; }

int Ask(int x, int res = 0) { for (; x; x -= x & -x) res += tree[x]; return res; }

int KthElement(int k) {
	int l = 1, r = SIZE - 5;
	while (l < r)
		if (Ask(mid) < k) l = mid + 1;
		else r = mid;
	return l;
}

signed main() {
	io.read(m), io.read(n), io.read(k);
	int L, R;
	for (int i = 1; i <= m; ++i) {
		io.read(a[i]);
		io.read(L);
		io.read(R);
		if (L < R) L += n + 1, R += n, In[L].pub(i), Out[R + 1].pub(i);
		else L ^= R ^= L ^= R, L += n, R += n + 1, In[1].pub(i), Out[L + 1].pub(i), In[R].pub(i);
	}
	int now = 0, x;
	for (int i = 1; i <= (n<<1); ++i) {
		for (int j = 0; j < In[i].size(); ++j) Add(a[In[i][j]], 1);
		for (int j = 0; j < Out[i].size(); ++j) Add(a[Out[i][j]], -1);
		now += In[i].size() - Out[i].size();
		if (now >= k) x = KthElement(now - k + 1), ans += (LL)x * x;
	}
	printf("%lld\n", ans);
	return 0;
}
```