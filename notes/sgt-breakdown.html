<!DOCTYPE html>
    <html lang=en>
        <head>
            <meta charset="UTF-8" />
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">

            <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>

            <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
                onload="renderMathInElement(document.body);"></script>
            <script src="/src/js/jquery.min.js"></script>
            <link rel="stylesheet" href="/src/styles/fonts.css" >
            <link rel="stylesheet" href="/src/styles/style.css" >
            <script>
                document.addEventListener("DOMContentLoaded", function() {
                    $("#giscus").load("/src/html/giscus.html")
                    $("#header").load("/src/html/header.html")
                    renderMathInElement(document.body, {
                        delimiters: [
                            {left: "$$", right: "$$", display: true},
                            {left: "$", right: "$", display: false}
                        ],
                        throwOnError: false,
                        errorColor: "#cc0000"
                    });
                })
            </script>
        </head>
        <body>
            <div class="content">
                <div id="header"></div>
                <p>没想到吧。</p>  
<p>其实本文旨在以 <strong>object oriented</strong> 的方式工程化地描述线段树的抽象结构，大概是在翻译 ACL 的 <code>lazysegtree</code>。</p>  
<p>在线段树上的结点中，有两种信息，分别称为 <code>S</code>，<code>F</code>，一个是维护的信息，一个是懒惰标记，又对应两个「空值」<code>e()</code> 和 <code>id()</code>。</p>  
<p>线段树依赖于两个儿子的值是 <code>S</code>，依赖于父亲的值是 <code>F</code>，定义一个函数 <code>op(x, y)</code>，其中 $x,y\in\mathbb{S}$ 表示 $x,y$ 合并的结果，这个规则是自定义的，且需要满足结合律和交换律；以及 <code>composition(x, y)</code>，其中 $x,y\in\mathbb{F}$，表示把懒惰标记 $x$ <strong>单向</strong>传递到懒惰标记 $y$ 上后的结果，其规则同样是自定义的。如果不理解为什么是单向请参考 <em>Range Affine, Range Sum</em> 问题。</p>  
<p>类似于 <code>composition(x, y)</code> 使得可以让一个在 $\mathbb{F}$ 中的元素传递到另一个属于 $\mathbb{F}$ 的元素身上，我们有 <code>mapping(x, y)</code> 表示从 $\mathbb{F}$ 到 $\mathbb{S}$ 的映射，其中 $x\in\mathbb{F}$，$y\in\mathbb{S}$。</p>  
<p>其实可以发现所谓的 <code>S</code> 就是一类<strong>幺半群</strong>（monoid），注意 <code>F</code> 显然不具有此类性质，但是 <code>F</code> 的 <code>composition(x, y)</code> 是有<strong>封闭性</strong>的。</p>  
<p><a href="https://www.luogu.com.cn/problem/P3373">例题 P3373，</a><a href="https://www.cnblogs.com/orchid-any/articles/15153763.html">示例代码见此处，特征码 acl-k。</a></p>  
<p>闲话，如果你的代码实现真的分这么细码量会激增哦。（</p>
                <script src="https://giscus.app/client.js" data-repo="cirnovsky/blog-comments" data-repo-id="R_kgDOKmz0Wg" data-category="General" data-category-id="DIC_kwDOKmz0Ws4Caiud" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="gruvbox" data-lang="en" crossorigin="anonymous" async></script>
            </div>
        </body>
    </html>
